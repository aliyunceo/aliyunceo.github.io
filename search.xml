<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Eureka配置详解</title>
      <link href="/2020/08/10/eureka-pei-zhi-xiang-jie/"/>
      <url>/2020/08/10/eureka-pei-zhi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Euraka配置详解"><a href="#Euraka配置详解" class="headerlink" title="Euraka配置详解"></a>Euraka配置详解</h1><p>Eureka包含四个部分的配置</p><ol><li>instance：当前Eureka Instance实例信息配置</li><li>client：Eureka Client客户端特性配置</li><li>server：Eureka Server注册中心特性配置</li><li>dashboard：Eureka Server注册中心仪表盘配置</li></ol><h2 id="Eureka-Instance实例信息配置"><a href="#Eureka-Instance实例信息配置" class="headerlink" title="Eureka Instance实例信息配置"></a>Eureka Instance实例信息配置</h2><p>Eureka Instance的配置信息全部保存在org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean配置类里，实际上它是com.netflix.appinfo.EurekaInstanceConfig的实现类，替代了netflix的com.netflix.appinfo.CloudInstanceConfig的默认实现。</p><p>Eureka Instance的配置信息全部以eureka.instance.xxx的格式配置。</p><p><strong>配置列表</strong></p><ul><li>appname = unknown</li></ul><p>应用名，首先获取spring.application.name的值，如果取值为空，则取默认unknown。</p><ul><li>appGroupName = null</li></ul><p>应用组名</p><ul><li>instanceEnabledOnit = false</li></ul><p>实例注册到Eureka上是，是否立刻开启通讯。有时候应用在准备好服务之前需要一些预处理。</p><ul><li>nonSecurePort = 80</li></ul><p>非安全的端口</p><ul><li>securePort = 443</li></ul><p>安全端口</p><ul><li>nonSecurePortEnabled = true</li></ul><p>是否开启非安全端口通讯</p><ul><li>securePortEnabled = false</li></ul><p>是否开启安全端口通讯</p><ul><li>leaseRenewalIntervalInSeconds = 30</li></ul><p>实例续约间隔时间</p><ul><li>leaseExpirationDurationInSeconds = 90</li></ul><p>实例超时时间，表示最大leaseExpirationDurationInSeconds秒后没有续约，Server就认为他不可用了，随之就会将其剔除。</p><ul><li>virtualHostName = unknown</li></ul><p>虚拟主机名，首先获取spring.application.name的值，如果取值为空，则取默认unknown。</p><ul><li>instanceId</li></ul><p>注册到eureka上的唯一实例ID，不能与相同appname的其他实例重复。</p><ul><li>secureVirtualHostName = unknown</li></ul><p>安全虚拟主机名，首先获取spring.application.name的值，如果取值为空，则取默认unknown。</p><ul><li>metadataMap = new HashMap();</li></ul><p>实例元数据，可以供其他实例使用。比如spring-boot-admin在监控时，获取实例的上下文和端口。</p><ul><li>dataCenterInfo = new MyDataCenterInfo(DataCenterInfo.Name.MyOwn);</li></ul><p>实例部署的数据中心。如AWS、MyOwn。</p><ul><li>ipAddress=null</li></ul><p>实例的IP地址</p><ul><li>statusPageUrlPath = “/actuator/info”</li></ul><p>实例状态页相对url</p><ul><li>statusPageUrl = null</li></ul><p>实例状态页绝对URL</p><ul><li>homePageUrlPath = “/“</li></ul><p>实例主页相对URL</p><ul><li>homePageUrl = null</li></ul><p>实例主页绝对URL</p><ul><li>healthCheckUrlUrlPath = “/actuator/health”</li></ul><p>实例健康检查相对URL</p><ul><li>healthCheckUrl = null</li></ul><p>实例健康检查绝对URL</p><ul><li>secureHealthCheckUrl = null</li></ul><p>实例安全的健康检查绝对URL</p><ul><li>namespace = “eureka”</li></ul><p>配置属性的命名空间（Spring Cloud中被忽略）</p><ul><li>hostname = null</li></ul><p>主机名,不配置的时候讲根据操作系统的主机名来获取</p><ul><li>preferIpAddress = false</li></ul><p>是否优先使用IP地址作为主机名的标识</p><h2 id="Eureka-Client客户端特性配置"><a href="#Eureka-Client客户端特性配置" class="headerlink" title="Eureka Client客户端特性配置"></a>Eureka Client客户端特性配置</h2><p>Eureka Client客户端特性配置是对作为Eureka客户端的特性配置，包括Eureka注册中心，本身也是一个Eureka Client。</p><p>Eureka Client特性配置全部在org.springframework.cloud.netflix.eureka.EurekaClientConfigBean中，实际上它是com.netflix.discovery.EurekaClientConfig的实现类，替代了netxflix的默认实现。</p><p>Eureka Client客户端特性配置全部以eureka.client.xxx的格式配置。</p><p><strong>配置列表</strong></p><ul><li>enabled=true</li></ul><p>是否启用Eureka client。</p><ul><li>registryFetchIntervalSeconds=30</li></ul><p>定时从Eureka Server拉取服务注册信息的间隔时间</p><ul><li>instanceInfoReplicationIntervalSeconds=30</li></ul><p>定时将实例信息（如果变化了）复制到Eureka Server的间隔时间。（InstanceInfoReplicator线程）</p><ul><li>initialInstanceInfoReplicationIntervalSeconds=40</li></ul><p>首次将实例信息复制到Eureka Server的延迟时间。（InstanceInfoReplicator线程）</p><ul><li>eurekaServiceUrlPollIntervalSeconds=300</li></ul><p>拉取Eureka Server地址的间隔时间（Eureka Server有可能增减）</p><ul><li>proxyPort=null</li></ul><p>Eureka Server的代理端口</p><ul><li>proxyHost=null</li></ul><p>Eureka Server的代理主机名</p><ul><li>proxyUserName=null</li></ul><p>Eureka Server的代理用户名</p><ul><li>proxyPassword=null</li></ul><p>Eureka Server的代理密码</p><ul><li>eurekaServerReadTimeoutSeconds=8</li></ul><p>从Eureka Server读取信息的超时时间</p><ul><li>eurekaServerConnectTimeoutSeconds=5</li></ul><p>连接Eureka Server的超时时间</p><ul><li>backupRegistryImpl=null</li></ul><p>Eureka Client第一次启动时获取服务注册信息的调用的回溯实现。Eureka Client启动时首次会检查有没有BackupRegistry的实现类，如果有实现类，则优先从这个实现类里获取服务注册信息。</p><ul><li>eurekaServerTotalConnections=200</li></ul><p>Eureka client连接Eureka Server的链接总数</p><ul><li>eurekaServerTotalConnectionsPerHost=50</li></ul><p>Eureka client连接单台Eureka Server的链接总数</p><ul><li>eurekaServerURLContext=null</li></ul><p>当Eureka server的列表在DNS中时，Eureka Server的上下文路径。如<a href="http://xxxx/eureka%E3%80%82">http://xxxx/eureka。</a></p><ul><li>eurekaServerPort=null</li></ul><p>当Eureka server的列表在DNS中时，Eureka Server的端口。</p><ul><li>eurekaServerDNSName=null</li></ul><p>当Eureka server的列表在DNS中时，且要通过DNSName获取Eureka Server列表时，DNS名字。</p><ul><li>region=”us-east-1”</li></ul><p>实例所属区域。</p><ul><li>eurekaConnectionIdleTimeoutSeconds = 30</li></ul><p>Eureka Client和Eureka Server之间的Http连接的空闲超时时间。</p><ul><li>heartbeatExecutorThreadPoolSize=2</li></ul><p>心跳（续约）执行器线程池大小。</p><ul><li>heartbeatExecutorExponentialBackOffBound=10</li></ul><p>心跳执行器在续约过程中超时后的再次执行续约的最大延迟倍数。默认最大延迟时间=10 * eureka.instance.leaseRenewalIntervalInSeconds</p><ul><li>cacheRefreshExecutorThreadPoolSize=2</li></ul><p>cacheRefreshExecutord的线程池大小（获取注册信息）</p><ul><li>cacheRefreshExecutorExponentialBackOffBound=10</li></ul><p>cacheRefreshExecutord的再次执行的最大延迟倍数。默认最大延迟时间=10 *eureka.client.registryFetchIntervalSeconds</p><ul><li>serviceUrl= new HashMap();serviceUrl.put(DEFAULT_ZONE, DEFAULT_URL);</li></ul><p>Eureka Server的分区地址。默认添加了一个defualtZone。也就是最常用的配置eureka.client.service-url.defaultZone=xxx</p><ul><li>registerWithEureka=true</li></ul><p>是否注册到Eureka Server。</p><ul><li>preferSameZoneEureka=true</li></ul><p>是否使用相同Zone下的Eureka server。</p><ul><li>logDeltaDiff=false</li></ul><p>是否记录Eureka Server和Eureka Client之间注册信息的差异</p><ul><li>disableDelta=false</li></ul><p>是否开启增量同步注册信息。</p><ul><li>fetchRemoteRegionsRegistry=null</li></ul><p>获取注册服务的远程地区，以逗号隔开。</p><ul><li>availabilityZones=new HashMap()</li></ul><p>可用分区列表。用逗号隔开。</p><ul><li>filterOnlyUpInstances = true</li></ul><p>是否只拉取UP状态的实例。</p><ul><li>fetchRegistry=true</li></ul><p>是否拉取注册信息。</p><ul><li>shouldUnregisterOnShutdown = true</li></ul><p>是否在停止服务的时候向Eureka Server发起Cancel指令。</p><ul><li>shouldEnforceRegistrationAtInit = false</li></ul><p>是否在初始化过程中注册服务。</p><h2 id="Eureka-Server注册中心端配置"><a href="#Eureka-Server注册中心端配置" class="headerlink" title="Eureka Server注册中心端配置"></a>Eureka Server注册中心端配置</h2><p>Eureka Server注册中心端的配置是对注册中心的特性配置。Eureka Server的配置全部在org.springframework.cloud.netflix.eureka.server.EurekaServerConfigBean里，实际上它是com.netflix.eureka.EurekaServerConfig的实现类，替代了netflix的默认实现。</p><p>Eureka Server的配置全部以eureka.server.xxx的格式进行配置。</p><p><strong>配置列表</strong></p><ul><li>enableSelfPreservation=true</li></ul><p>是否开启自我保护</p><ul><li>renewalPercentThreshold = 0.85</li></ul><p>自我保护续约百分比阀值因子。如果实际续约数小于续约数阀值，则开启自我保护</p><ul><li>renewalThresholdUpdateIntervalMs = 15 * 60 * 1000</li></ul><p>续约数阀值更新频率。</p><ul><li>peerEurekaNodesUpdateIntervalMs = 10 * 60 * 1000</li></ul><p>Eureka Server节点更新频率。</p><ul><li>enableReplicatedRequestCompression = false</li></ul><p>是否启用复制请求压缩。</p><ul><li>waitTimeInMsWhenSyncEmpty=5 * 60 * 1000</li></ul><p>当从其他节点同步实例信息为空时等待的时间。</p><ul><li>peerNodeConnectTimeoutMs=200</li></ul><p>节点间连接的超时时间。</p><ul><li>peerNodeReadTimeoutMs=200</li></ul><p>节点间读取信息的超时时间。</p><ul><li>peerNodeTotalConnections=1000</li></ul><p>节点间连接总数。</p><ul><li>peerNodeTotalConnectionsPerHost = 500;</li></ul><p>单个节点间连接总数。</p><ul><li>peerNodeConnectionIdleTimeoutSeconds = 30;</li></ul><p>节点间连接空闲超时时间。</p><ul><li>retentionTimeInMSInDeltaQueue = 3 * MINUTES;</li></ul><p>增量队列的缓存时间。</p><ul><li>deltaRetentionTimerIntervalInMs = 30 * 1000;</li></ul><p>清理增量队列中过期的频率。</p><ul><li>evictionIntervalTimerInMs = 60 * 1000;</li></ul><p>剔除任务频率。</p><ul><li>responseCacheAutoExpirationInSeconds = 180;</li></ul><p>注册列表缓存超时时间（当注册列表没有变化时）</p><ul><li>responseCacheUpdateIntervalMs = 30 * 1000;</li></ul><p>注册列表缓存更新频率。</p><ul><li>useReadOnlyResponseCache = true;</li></ul><p>是否开启注册列表的二级缓存。</p><ul><li>disableDelta=false。</li></ul><p>是否为client提供增量信息。</p><ul><li>maxThreadsForStatusReplication = 1;</li></ul><p>状态同步的最大线程数。</p><ul><li>maxElementsInStatusReplicationPool = 10000;</li></ul><p>状态同步队列的最大容量。</p><ul><li>syncWhenTimestampDiffers = true;</li></ul><p>当时间差异时是否同步。</p><ul><li>registrySyncRetries = 0;</li></ul><p>注册信息同步重试次数。</p><ul><li>registrySyncRetryWaitMs = 30 * 1000;</li></ul><p>注册信息同步重试期间的时间间隔。</p><ul><li>maxElementsInPeerReplicationPool = 10000;</li></ul><p>节点间同步事件的最大容量。</p><ul><li>minThreadsForPeerReplication = 5;</li></ul><p>节点间同步的最小线程数。</p><ul><li>maxThreadsForPeerReplication = 20;</li></ul><p>节点间同步的最大线程数。</p><ul><li>maxTimeForReplication = 30000;</li></ul><p>节点间同步的最大时间，单位为毫秒。</p><ul><li>disableDeltaForRemoteRegions = false；</li></ul><p>是否启用远程区域增量。</p><ul><li>remoteRegionConnectTimeoutMs = 1000;</li></ul><p>远程区域连接超时时间。</p><ul><li>remoteRegionReadTimeoutMs = 1000;</li></ul><p>远程区域读取超时时间。</p><ul><li>remoteRegionTotalConnections = 1000;</li></ul><p>远程区域最大连接数</p><ul><li>remoteRegionTotalConnectionsPerHost = 500;</li></ul><p>远程区域单机连接数</p><ul><li>remoteRegionConnectionIdleTimeoutSeconds = 30;</li></ul><p>远程区域连接空闲超时时间。</p><ul><li>remoteRegionRegistryFetchInterval = 30;</li></ul><p>远程区域注册信息拉取频率。</p><ul><li>remoteRegionFetchThreadPoolSize = 20;</li></ul><p>远程区域注册信息线程数。</p><h2 id="Eureka-Server注册中心仪表盘配置"><a href="#Eureka-Server注册中心仪表盘配置" class="headerlink" title="Eureka Server注册中心仪表盘配置"></a><strong>Eureka Server注册中心仪表盘配置</strong></h2><p>注册中心仪表盘的配置主要是控制注册中心的可视化展示。以eureka.dashboard.xxx的格式配置。</p><ul><li>path=”/“</li></ul><p>仪表盘访问路径</p><ul><li>enabled=true</li></ul><p>是否启用仪表盘</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud概述</title>
      <link href="/2020/08/10/spring-cloud-gai-shu/"/>
      <url>/2020/08/10/spring-cloud-gai-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-微服务架构"><a href="#1-微服务架构" class="headerlink" title="1.微服务架构"></a>1.微服务架构</h3><ul><li><p>微服务架构的演变</p><p><img src="/2020/08/10/spring-cloud-gai-shu/001.jpg"></p></li><li><p>微服务架构的描述</p><p>（1）微服务是系统架构上的一种设计风格,它的主旨是将一个原本独立的系统拆分成多个小型服务,这些小型服务都在各自独立的进程中运行,服务之间一般通过 HTTP 的 RESTfuL API 进行通信协作。</p><p>（2）被拆分成的每一个小型服务都围绕着系统中的某一项或些耦合度较高的业务功能进行构建,并且每个服务都维护着白身的数据存储、业务开发自动化测试案例以及独立部署机制。</p><p>（3）由于有了轻量级的通信协作基础,所以这些微服务可以使用不同的语言来编写。 </p></li></ul><p><img src="/2020/08/10/spring-cloud-gai-shu/002.jpg"></p><h3 id="2-Spring-Cloud"><a href="#2-Spring-Cloud" class="headerlink" title="2.Spring Cloud"></a>2.Spring Cloud</h3><ul><li><p>描述</p><p>Spring Cloud 是一系列框架的有序集合。</p><p>Spring Cloud 并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来。</p><p>通过 Spring Boot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><p>它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、 断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p><p>Spring Cloud项目官方网址：<a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a> </p></li></ul><p><img src="/2020/08/10/spring-cloud-gai-shu/003.jpg"></p><p>​         </p><p>​        Spring Cloud 版本命名方式采用了伦敦地铁站的名称，同时根据字母表的顺序来对应版本时间顺序，比如：最早的Release版本：Angel，第二个Release版本：Brixton，然后是Camden、    Dalston、Edgware，Finchley，Greenwich，Hoxton。</p><h3 id="3-Spring-Cloud与Dubbo对比"><a href="#3-Spring-Cloud与Dubbo对比" class="headerlink" title="3.Spring Cloud与Dubbo对比"></a>3.Spring Cloud与Dubbo对比</h3><ul><li>Spring Cloud 与 Dubbo 都是实现微服务有效的工具。</li><li>Dubbo 只是实现了服务治理，而 Spring Cloud 子项目分别覆盖了微服务架构下的众多部件。</li><li>Dubbo 使用 RPC 通讯协议，Spring Cloud 使用 RESTful 完成通信，Dubbo 效率略高于 Spring Cloud</li></ul><p><img src="/2020/08/10/spring-cloud-gai-shu/004.jpg"></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>​    微服务就是将项目的各个模块拆分为可独立运行、部署、测试的架构设计风格。</p><p>​    Spring 公司将其他公司中微服务架构常用的组件整合起来，并使用 SpringBoot 简化其开发、配置。称为 Spring Cloud</p><p>​    Spring Cloud 与 Dubbo都是实现微服务有效的工具。Dubbo 性能更好，而 Spring Cloud 功能更全面。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ基本程序编写</title>
      <link href="/2020/08/09/rabbitmq-ji-ben-cheng-xu-bian-xie/"/>
      <url>/2020/08/09/rabbitmq-ji-ben-cheng-xu-bian-xie/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-搭建示例工程"><a href="#3-1-搭建示例工程" class="headerlink" title="3.1. 搭建示例工程"></a>3.1. 搭建示例工程</h2><h3 id="3-1-1-创建工程"><a href="#3-1-1-创建工程" class="headerlink" title="3.1.1. 创建工程"></a>3.1.1. 创建工程</h3><p><img src="/2020/08/09/rabbitmq-ji-ben-cheng-xu-bian-xie/1558319510387.png"></p><p><img src="/2020/08/09/rabbitmq-ji-ben-cheng-xu-bian-xie/1558319546688.png"></p><h3 id="3-1-2-添加依赖"><a href="#3-1-2-添加依赖" class="headerlink" title="3.1.2. 添加依赖"></a>3.1.2. 添加依赖</h3><p>往aliyun-rabbitmq的pom.xml文件中添加如下依赖：</p><pre class=" language-xml"><code class="language-xml">        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.rabbitmq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>amqp-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.6.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h2 id="3-2-编写生产者"><a href="#3-2-编写生产者" class="headerlink" title="3.2. 编写生产者"></a>3.2. 编写生产者</h2><p>编写消息生产者ren.aliyun.rabbitmq.simple.Producer</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> ren<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>simple<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Channel<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Connection<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>ConnectionFactory<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> String QUEUE_NAME <span class="token operator">=</span> <span class="token string">"simple_queue"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建连接工厂</span>        ConnectionFactory connectionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//主机地址;默认为 localhost</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//连接端口;默认为 5672</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//虚拟主机名称;默认为 /</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/aliyun"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//连接用户名；默认为guest</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"aliyun"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//连接密码；默认为guest</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"aliyun"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建连接</span>        Connection connection <span class="token operator">=</span> connectionFactory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建频道</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 声明（创建）队列</span>        <span class="token comment" spellcheck="true">/**         * 参数1：队列名称         * 参数2：是否定义持久化队列         * 参数3：是否独占本次连接         * 参数4：是否在不使用的时候自动删除队列         * 参数5：队列其它参数         */</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 要发送的信息</span>        String message <span class="token operator">=</span> <span class="token string">"你好；小兔子！"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 参数1：交换机名称，如果没有指定则使用默认Default Exchage         * 参数2：路由key,简单模式可以传递队列名称         * 参数3：消息其它属性         * 参数4：消息内容         */</span>        channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> QUEUE_NAME<span class="token punctuation">,</span> null<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已发送消息："</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 关闭资源</span>        channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>在执行上述的消息发送之后；可以登录rabbitMQ的管理控制台，可以发现队列和其消息：</p><p><img src="/2020/08/09/rabbitmq-ji-ben-cheng-xu-bian-xie/1556006638979.png"></p><p><img src="/2020/08/09/rabbitmq-ji-ben-cheng-xu-bian-xie/1556006647177.png"></p><h2 id="3-3-编写消费者"><a href="#3-3-编写消费者" class="headerlink" title="3.3. 编写消费者"></a>3.3. 编写消费者</h2><p>抽取创建connection的工具类ren.aliyun.rabbitmq.util.ConnectionUtil；</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> ren<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>util<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Connection<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>ConnectionFactory<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConnectionUtil</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Connection <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建连接工厂</span>        ConnectionFactory connectionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//主机地址;默认为 localhost</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//连接端口;默认为 5672</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//虚拟主机名称;默认为 /</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/aliyun"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//连接用户名；默认为guest</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"aliyun"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//连接密码；默认为guest</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"aliyun"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建连接</span>        <span class="token keyword">return</span> connectionFactory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>编写消息的消费者ren.aliyun.rabbitmq.simple.Consumer</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> ren<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>simple<span class="token punctuation">;</span><span class="token keyword">import</span> ren<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ConnectionUtil<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建频道</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 声明（创建）队列</span>        <span class="token comment" spellcheck="true">/**         * 参数1：队列名称         * 参数2：是否定义持久化队列         * 参数3：是否独占本次连接         * 参数4：是否在不使用的时候自动删除队列         * 参数5：队列其它参数         */</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>Producer<span class="token punctuation">.</span>QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建消费者；并设置消息处理</span>        DefaultConsumer consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token comment" spellcheck="true">/**             * consumerTag 消息者标签，在channel.basicConsume时候可以指定             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)             * properties 属性信息             * body 消息             */</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//路由key</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"路由key为："</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getRoutingKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//交换机</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"交换机为："</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//消息id</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消息id为："</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//收到的消息</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到的消息为："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//监听消息</span>        <span class="token comment" spellcheck="true">/**         * 参数1：队列名称         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认         * 参数3：消息接收到后回调         */</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>Producer<span class="token punctuation">.</span>QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//不关闭资源，应该一直监听消息</span>        <span class="token comment" spellcheck="true">//channel.close();</span>        <span class="token comment" spellcheck="true">//connection.close();</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4. 小结"></a>3.4. 小结</h2><p>上述的入门案例中中其实使用的是如下的简单模式：</p><p><img src="/2020/08/09/rabbitmq-ji-ben-cheng-xu-bian-xie/1555991074575.png"></p><p>在上图的模型中，有以下概念：</p><ul><li>P：生产者，也就是要发送消息的程序</li><li>C：消费者：消息的接受者，会一直等待消息到来。</li><li>queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件概述</title>
      <link href="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/"/>
      <url>/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-什么是消息中间件"><a href="#1-1-什么是消息中间件" class="headerlink" title="1.1. 什么是消息中间件"></a>1.1. 什么是消息中间件</h2><p>MQ全称为Message Queue，消息队列是应用程序和应用程序之间的通信方法，是在消息的传输过程中保存消息的容器，多用于分布式系统之间进行通信。</p><ul><li><p>总结<br>MQ，消息队列，存储消息的中间件<br>分布式系统通信两种方式：直接远程调用 和 借助第三方 完成间接通信<br>发送方称为生产者，接收方称为消费者</p></li><li><p>为什么使用MQ</p><p>在项目中，可将一些无需即时返回且耗时的操作提取出来，进行<strong>异步处理</strong>，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而<strong>提高</strong>了<strong>系统</strong>的<strong>吞吐量</strong>。</p></li><li><p>MQ的优势(开发中消息队列通常有如下应用场景)：</p><p>1、任务<strong>异步</strong>处理</p><p>将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。</p><p><img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/yb1.jpg"></p><p><img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/yb2.jpg"></p><p>2、应用程序<strong>解耦合</strong></p><p>MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。</p></li></ul><p><img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/y1.jpg"><br><img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/y2.jpg"></p><p>  3、<strong>削峰填谷</strong></p><p>  如订单系统，在下单的时候就会往数据库写数据。但是数据库只能支撑每秒1000左右的并发写入，并发量再高就容易宕机。低峰期的时候并发也就100多个，但是在高峰期时候，并发量会突然激增到5000以上，这个时候数据库肯定卡死了。</p><p>  <img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/01.jpg"></p><p>  消息被MQ保存起来了，然后系统就可以按照自己的消费能力来消费，比如每秒1000个数据，这样慢慢写入数据库，这样就不会卡死数据库了。</p><p>  <img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/02.jpg"></p><p>  但是使用了MQ之后，限制消费消息的速度为1000，但是这样一来，高峰期产生的数据势必会被积压在MQ中，高峰就被“削”掉了。但是因为消息积压，在高峰期过后的一段时间内，消费消息的速度还是会维持在1000QPS，直到消费完积压的消息,这就叫做“填谷”</p><p>  <img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/03.jpg"></p><p><img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/xf1.jpg"></p><p><img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/xf2.jpg"></p><ul><li><p>MQ的劣势</p><p>系统可用性降低（系统引入的外部依赖越多，系统稳定性越差。一旦 MQ 宕机，就会对业务造成影响。如何保证MQ的高可用？）<br>系统复杂度提高（MQ 的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过 MQ 进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？）<br>一致性问题（A 系统处理完业务，通过 MQ 给B、C、D三个系统发消息数据，如果 B 系统、C 系统处理成功，D 系统处理失败。如何保证消息数据处理的一致性？）</p></li><li><p>既然 MQ 有优势也有劣势，那么使用 MQ 需要满足什么条件呢？</p><p>①生产者不需要从消费者处获得反馈。引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做，上层却当成动作做完了继续往后走，即所谓异步成为了可能。</p><p>②容许短暂的不一致性。</p><p>③确实是用了有效果。即解耦、提速、削峰这些方面的收益，超过加入MQ，管理MQ这些成本。</p></li></ul><h2 id="1-2-AMQP-和-JMS"><a href="#1-2-AMQP-和-JMS" class="headerlink" title="1.2. AMQP 和 JMS"></a>1.2. AMQP 和 JMS</h2><p>MQ是消息通信的模型；实现MQ的大致有两种主流方式：AMQP、JMS。</p><h3 id="1-2-1-AMQP"><a href="#1-2-1-AMQP" class="headerlink" title="1.2.1. AMQP"></a>1.2.1. AMQP</h3><p>AMQP（高级队列协议）是一种网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。2006年，AMQP 规范发布。类比HTTP。更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。</p><h3 id="1-2-2-JMS"><a href="#1-2-2-JMS" class="headerlink" title="1.2.2. JMS"></a>1.2.2. JMS</h3><p>JMS即Java消息服务（JavaMessage Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p><p>JMS 是 JavaEE 规范中的一种，类比JDBC</p><p>l很多消息中间件都实现了JMS规范，例如：ActiveMQ。RabbitMQ 官方没有提供 JMS 的实现包，但是开源社区有</p><h3 id="1-2-3-AMQP-与-JMS-区别"><a href="#1-2-3-AMQP-与-JMS-区别" class="headerlink" title="1.2.3. AMQP 与 JMS 区别"></a>1.2.3. AMQP 与 JMS 区别</h3><ul><li>JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式</li><li>JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。</li><li>JMS规定了两种消息模式；而AMQP的消息模式更加丰富</li></ul><h2 id="1-3-消息队列产品"><a href="#1-3-消息队列产品" class="headerlink" title="1.3. 消息队列产品"></a>1.3. 消息队列产品</h2><p>市场上常见的消息队列有如下：</p><ul><li>ActiveMQ：基于JMS</li><li>ZeroMQ：基于C语言开发</li><li>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好</li><li>RocketMQ：基于JMS，阿里巴巴产品</li><li>Kafka：类似MQ的产品；分布式消息系统，高吞吐量</li></ul><h2 id="1-4-RabbitMQ"><a href="#1-4-RabbitMQ" class="headerlink" title="1.4. RabbitMQ"></a>1.4. RabbitMQ</h2><p>RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。</p><p>RabbitMQ官方地址：<a href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a></p><p><img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/RabbitMQ.jpg"></p><p>RabbitMQ 中的相关概念：</p><p>​        lBroker：接收和分发消息的应用，RabbitMQ Server就是 Message Broker</p><p>​        Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中    的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，    每个用户在自己的 vhost 创建 exchange／queue 等</p><p>​        Connection：publisher／consumer 和 broker 之间的 TCP 连接</p><p>​        Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection的    开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通    常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker     识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建    立 TCP connection 的开销</p><p>RabbitMQ提供了6种模式：简单模式，work模式，Publish/Subscribe发布与订阅模式，Routing路由模式，Topics主题模式，RPC远程调用模式（远程调用，不太算MQ；暂不作介绍）；</p><p>官网对应模式介绍：<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></p><p><img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/1555988678324.jpg" alt="1555988678324"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ安装说明</title>
      <link href="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/"/>
      <url>/2020/08/07/rabbitmq-an-zhuang-shuo-ming/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装依赖环境"><a href="#1-安装依赖环境" class="headerlink" title="1. 安装依赖环境"></a>1. 安装依赖环境</h2><p>在线安装依赖环境：</p><pre class=" language-shell"><code class="language-shell">yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz</code></pre><h2 id="2-安装Erlang"><a href="#2-安装Erlang" class="headerlink" title="2. 安装Erlang"></a>2. 安装Erlang</h2><p>上传</p><p>erlang-18.3-1.el7.centos.x86_64.rpm<br>socat-1.7.3.2-5.el7.lux.x86_64.rpm<br>rabbitmq-server-3.6.5-1.noarch.rpm</p><pre class=" language-sh"><code class="language-sh"># 安装rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm</code></pre><p>如果出现如下错误</p><p><img src="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/assets/1565526174751.png"></p><p>说明gblic 版本太低。我们可以查看当前机器的gblic 版本</p><pre class=" language-shell"><code class="language-shell">strings /lib64/libc.so.6 | grep GLIBC</code></pre><p><img src="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/assets/1565526264426.png"></p><p>当前最高版本2.12，需要2.15.所以需要升级glibc</p><ul><li><p>使用yum更新安装依赖</p><pre class=" language-shell"><code class="language-shell">sudo yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make -y</code></pre></li><li><p>下载rpm包</p><pre class=" language-shell"><code class="language-shell">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-utils-2.17-55.el6.x86_64.rpm &wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-static-2.17-55.el6.x86_64.rpm &wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-2.17-55.el6.x86_64.rpm &wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-common-2.17-55.el6.x86_64.rpm &wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-devel-2.17-55.el6.x86_64.rpm &wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-headers-2.17-55.el6.x86_64.rpm &wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/nscd-2.17-55.el6.x86_64.rpm &</code></pre></li><li><p>安装rpm包</p><pre class=" language-shell"><code class="language-shell">sudo rpm -Uvh *-2.17-55.el6.x86_64.rpm --force --nodeps</code></pre></li><li><p>安装完毕后再查看glibc版本,发现glibc版本已经到2.17了</p><pre class=" language-shell"><code class="language-shell">strings /lib64/libc.so.6 | grep GLIBC</code></pre></li></ul><p><img src="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/assets/1565528746057.png"></p><h2 id="3-安装RabbitMQ"><a href="#3-安装RabbitMQ" class="headerlink" title="3. 安装RabbitMQ"></a>3. 安装RabbitMQ</h2><pre class=" language-sh"><code class="language-sh"># 安装rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm# 安装rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm</code></pre><h2 id="4-开启管理界面及配置"><a href="#4-开启管理界面及配置" class="headerlink" title="4. 开启管理界面及配置"></a>4. 开启管理界面及配置</h2><pre class=" language-sh"><code class="language-sh"># 开启管理界面rabbitmq-plugins enable rabbitmq_management# 修改默认配置信息vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app # 比如修改密码、配置等等，例如：loopback_users 中的 <<"guest">>,只保留guest</code></pre><h2 id="5-启动"><a href="#5-启动" class="headerlink" title="5. 启动"></a>5. 启动</h2><pre class=" language-sh"><code class="language-sh">service rabbitmq-server start # 启动服务service rabbitmq-server stop # 停止服务service rabbitmq-server restart # 重启服务</code></pre><ul><li>设置配置文件</li></ul><pre class=" language-shell"><code class="language-shell">cd /usr/share/doc/rabbitmq-server-3.6.5/cp rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</code></pre><h2 id="6-配置虚拟主机及用户"><a href="#6-配置虚拟主机及用户" class="headerlink" title="6. 配置虚拟主机及用户"></a>6. 配置虚拟主机及用户</h2><h3 id="6-1-用户角色"><a href="#6-1-用户角色" class="headerlink" title="6.1. 用户角色"></a>6.1. 用户角色</h3><p>RabbitMQ在安装好后，可以访问<code>http://ip地址:15672</code> ；其自带了guest/guest的用户名和密码；如果需要创建自定义用户；那么也可以登录管理界面后，如下操作：</p><p><img src="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/assets/1565098043833.png"> </p><p><img src="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/assets/1565098315375.png"></p><p><strong>角色说明</strong>：</p><p>1、 超级管理员(administrator)</p><p>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p><p>2、 监控者(monitoring)</p><p>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p><p>3、 策略制定者(policymaker)</p><p>可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</p><p>4、 普通管理者(management)</p><p>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</p><p>5、 其他</p><p>无法登陆管理控制台，通常就是普通的生产者和消费者。</p><h3 id="6-2-Virtual-Hosts配置"><a href="#6-2-Virtual-Hosts配置" class="headerlink" title="6.2. Virtual Hosts配置"></a>6.2. Virtual Hosts配置</h3><p>像mysql拥有数据库的概念并且可以指定用户对库和表等操作的权限。RabbitMQ也有类似的权限管理；在RabbitMQ中可以虚拟消息服务器Virtual Host，每个Virtual Hosts相当于一个相对独立的RabbitMQ服务器，每个VirtualHost之间是相互隔离的。exchange、queue、message不能互通。 相当于mysql的db。Virtual Name一般以/开头。</p><h4 id="6-2-1-创建Virtual-Hosts"><a href="#6-2-1-创建Virtual-Hosts" class="headerlink" title="6.2.1. 创建Virtual Hosts"></a>6.2.1. 创建Virtual Hosts</h4><p><img src="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/assets/1565098496482.png"></p><h4 id="6-2-2-设置Virtual-Hosts权限"><a href="#6-2-2-设置Virtual-Hosts权限" class="headerlink" title="6.2.2. 设置Virtual Hosts权限"></a>6.2.2. 设置Virtual Hosts权限</h4><p><img src="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/assets/1565098585317.png"></p><p><img src="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/assets/1565098719054.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
