<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>各类实用网站</title>
      <link href="/2020/12/14/ge-lei-shi-yong-wang-zhan/"/>
      <url>/2020/12/14/ge-lei-shi-yong-wang-zhan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>稿定设计： 批图</p></blockquote><blockquote><p>Convertio：文件转换</p></blockquote><blockquote><p>5118.com： 找数据</p></blockquote><blockquote><p>officeplus：办公模板</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis的架构设计</title>
      <link href="/2020/12/10/mybatis-de-jia-gou-she-ji/"/>
      <url>/2020/12/10/mybatis-de-jia-gou-she-ji/</url>
      
        <content type="html"><![CDATA[<h4 id="1-架构图示"><a href="#1-架构图示" class="headerlink" title="1.架构图示"></a>1.架构图示</h4><p><img src="/2020/12/10/mybatis-de-jia-gou-she-ji/1.png"></p><blockquote><p>(1) API接口层：提供给外部使用的接口 API，开发人员通过这些本地API来操纵数据库。接口层一接收 到 调用请求就会调用数据处理层来完成具体的数据处理。</p><p> MyBatis和数据库的交互有两种方式：</p><pre><code> a. 使用传统的MyBati s提供的API ； b. 使用Mapper代理的方式</code></pre><p> (2) 数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根 据调用的请求完成一次数据库操作。</p><p> (3) 基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是 共 用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑</p><p><img src="/2020/12/10/mybatis-de-jia-gou-she-ji/2.png"></p></blockquote><blockquote><p><img src="/2020/12/10/mybatis-de-jia-gou-she-ji/3.png"></p></blockquote><h4 id="2-总结流程"><a href="#2-总结流程" class="headerlink" title="2.总结流程"></a>2.总结流程</h4><p>(1) 加载配置并初始化 触发条件：加载配置文件 配置来源于两个地方，一个是配置文件(主配置文件conf.xml,mapper文件*.xml),—个是java代码中的 注解，将主配置文件内容解析封装到Configuration,将sql的配置信息加载成为一个mappedstatement 对象，存储在内存之中 </p><p>(2) 接收调用请求 触发条件：调用Mybatis提供的API 传入参数：为SQL的ID和传入参数对象 处理过程：将请求传递给下层的请求处理层进行处理。</p><p>(3) 处理操作请求 触发条件：API接口层传递请求过来 传入参数：为SQL的ID和传入参数对象 处理过程：</p><p>​     (A) 根据SQL的ID查找对应的MappedStatement对象。</p><p>​     (B) 根据传入参数对象解析MappedStatement对象，得到最终要执行的SQL和执行传入参数。</p><p>​     (C) 获取数据库连接，根据得到的最终SQL语句和执行传入参数到数据库执行，并得到执行结果。</p><p>​     (D) 根据MappedStatement对象中的结果映射配置对得到的执行结果进行转换处理，并得到最终的处理结果。</p><p>(E) 释放连接资源。 </p><p>(4) 返回处理结果 将最终的处理结果返回。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对mybatis插件的研究</title>
      <link href="/2020/12/08/dui-mybatis-cha-jian-de-yan-jiu/"/>
      <url>/2020/12/08/dui-mybatis-cha-jian-de-yan-jiu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-mybatis插件的机制与原理"><a href="#1-mybatis插件的机制与原理" class="headerlink" title="1.mybatis插件的机制与原理"></a>1.mybatis插件的机制与原理</h3><h4 id="1-1插件介绍"><a href="#1-1插件介绍" class="headerlink" title="1.1插件介绍"></a>1.1插件介绍</h4><blockquote><p>一般情况下，开源框架都会提供插件或其他形式的拓展点，供开发者自行拓展。这样的好处是显而易见 的，一是增加了框架的灵活性。二是开发者可以结合实际需求，对框架进行拓展，使其能够更好的工 作。以MyBatis为例，我们可基于MyBati s插件机制实现分页、分表，监控等功能。由于插件和业务无关，业务也无法感知插件的存在。因此可以无感植入插件，在无形中增强功能</p></blockquote><p>总结：</p><blockquote><p>插件功能：</p><p>增加了框架的灵活性；</p><p>对框架进行拓展，，使其能够更好的工作</p></blockquote><h4 id="1-2mybatis插件介绍"><a href="#1-2mybatis插件介绍" class="headerlink" title="1.2mybatis插件介绍"></a>1.2mybatis插件介绍</h4><blockquote><p>Mybati s作为一个应用广泛的优秀的ORM开源框架，这个框架具有强大的灵活性，在四大组件 (Executor、StatementHandler、ParameterHandler、ResultSetHandler)处提供了简单易用的插件扩展机制。Mybatis对持久层的操作就是借助于四大核心对象。MyBatis支持用插件对四大核心对象进行拦截，对mybatis来说插件就是拦截器，用来增强核心对象的功能，增强功能本质上是借助于底层的动态代理实现的，换句话说，MyBatis中的四大对象都是代理对象</p><p>作用：对核心功能进行增强</p><p>增强功能本质上是借助于底层的动态代理实现的</p><p>MyBatis中的四大对象都是代理对象</p></blockquote><p>四大组件的功能：</p><blockquote><p> 执行器Executor (update、query、commit、rollback等方法)；           执行器 ，负责增删改查的行为</p><p> SQL语法构建器StatementHandler (prepare、parameterize、batch、updates query等方 法)； sql语句构建器，完成sql的预编译</p><p> 参数处理器ParameterHandler (getParameterObject、setParameters方法)；     参数处理器，设置参数</p><p> 结果集处理器ResultSetHandler (handleResultSets、handleOutputParameters等方法)； 结果集处理器，用来处理返回结果集</p><p><img src="/2020/12/08/dui-mybatis-cha-jian-de-yan-jiu/1.png"></p></blockquote><h4 id="1-3-mybatis插件的原理"><a href="#1-3-mybatis插件的原理" class="headerlink" title="1.3 mybatis插件的原理"></a>1.3 mybatis插件的原理</h4><p>在四大对象创建的时候</p><blockquote><p>1、每个创建出来的对象不是直接返回的，而是interceptorChain.pluginAll(parameterHandler); </p><p>2、获取到所有的Interceptor (拦截器)(插件需要实现的接口)；调用 interceptor.plugin(target);返 回 target 包装后的对象 </p><p>3、插件机制，我们可以使用插件为目标对象创建一个代理对象；AOP (面向切面)我们的插件可 以 为四大对象创建出代理对象，代理对象就可以拦截到四大对象的每一个执行;</p></blockquote><p>插件拦截并附加额外的功能</p><blockquote><p><img src="/2020/12/08/dui-mybatis-cha-jian-de-yan-jiu/2.png"></p><p>interceptorChain保存了所有的拦截器(interceptors)，是mybatis初始化的时候创建的。调用拦截器链 中的拦截器依次的对目标进行拦截或增强。interceptor.plugin(target)中的target就可以理解为mybatis 中的四大对象。返回的target是被重重代理后的对象</p></blockquote><p>如果我们想要拦截Executor的query方法，那么可以这样定义插件：</p><blockquote><p><img src="/2020/12/08/dui-mybatis-cha-jian-de-yan-jiu/3.png"></p></blockquote><p>最后需将插件配置到sqlMapConfig.xml中。</p><blockquote><p><img src="/2020/12/08/dui-mybatis-cha-jian-de-yan-jiu/4.png"></p><p>MyBatis在启动时可以加载插件，并保存插件实例到相关对象(InterceptorChain，拦截器链) 中。 待准备工作做完后，MyBatis处于就绪状态。我们在执行SQL时，需要先通过 DefaultSqlSessionFactory 创建 SqlSession。Executor 实例会在创建 SqlSession 的过程中被创建， Executor实例创建完毕后，MyBatis会通过JDK动态代理为实例生成代理类。这样，插件逻辑即可在 Executor相关方法被调用前执行。</p></blockquote><h3 id="2-mybatis插件机制之自定义mybatis插件"><a href="#2-mybatis插件机制之自定义mybatis插件" class="headerlink" title="2.mybatis插件机制之自定义mybatis插件"></a>2.mybatis插件机制之自定义mybatis插件</h3><h4 id="2-1插件接口"><a href="#2-1插件接口" class="headerlink" title="2.1插件接口"></a>2.1插件接口</h4><p>Mybatis 插件接口</p><blockquote><p>Intercept方法，插件的核心方法 </p><p>plugin方法，生成target的代理对象 </p><p>setProperties方法，传递插件所需参数</p></blockquote><h4 id="2-2自定义插件"><a href="#2-2自定义插件" class="headerlink" title="2.2自定义插件"></a>2.2自定义插件</h4><p>步骤：</p><p>1.实现intercept接口并实现intercept里面的方法</p><p>2.配置自定义的插件类</p><p><img src="/2020/12/08/dui-mybatis-cha-jian-de-yan-jiu/6.png"></p><p><img src="/2020/12/08/dui-mybatis-cha-jian-de-yan-jiu/7.png"></p><p><img src="/2020/12/08/dui-mybatis-cha-jian-de-yan-jiu/8.png"></p><h3 id="3-mybatis插件机制之plugin源码分析"><a href="#3-mybatis插件机制之plugin源码分析" class="headerlink" title="3.mybatis插件机制之plugin源码分析"></a>3.mybatis插件机制之plugin源码分析</h3><p>插接执行逻辑</p><blockquote><p>Plugin实现了 InvocationHandler接口，因此它的invoke方法会拦截所有的方法调用。invoke方法会对所拦截的方法进行检测，以决定是否执行插件逻辑。该方法的逻辑如下：</p></blockquote><blockquote><p><img src="/2020/12/08/dui-mybatis-cha-jian-de-yan-jiu/9.png"></p><p>invoke方法的代码比较少，逻辑不难理解。首先,invoke方法会检测被拦截方法是否配置在插件的 @Signature注解中，若是，则执行插件逻辑，否则执行被拦截方法。插件逻辑封装在intercept中，该 方法的参数类型为Invocationo Invocation主要用于存储目标类，方法以及方法参数列表。</p></blockquote><h3 id="4-mybatis插件机制之pageHelper"><a href="#4-mybatis插件机制之pageHelper" class="headerlink" title="4.mybatis插件机制之pageHelper"></a>4.mybatis插件机制之pageHelper</h3><blockquote></blockquote><h3 id="5-mybatis插件机制之通用mapper"><a href="#5-mybatis插件机制之通用mapper" class="headerlink" title="5.mybatis插件机制之通用mapper"></a>5.mybatis插件机制之通用mapper</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解mybatis的缓存技术</title>
      <link href="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/"/>
      <url>/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-缓存介绍"><a href="#1-缓存介绍" class="headerlink" title="1.缓存介绍"></a>1.缓存介绍</h3><p>缓存就是内存中的数据，常常来自对数据库查询结果的保存，使用缓存，我们可以避免频繁的与数据库进行交互，进而提高响应速度</p><p>mybatis也提供了对缓存的支持，分为一级缓存和二级缓存，可以通过下图来理解：</p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/1.PNG"></p><blockquote><p>一级缓存是SqlSession级别的缓存，在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（hashmap）用来存储缓存数据。不同的sqlSession之间的缓存数据区域（hashmap）是互相不影响的</p><p>二级缓存是mapper级别的缓存，多个sqlSession去操作同一个Mapper的sql语句，多个sqlSession可以共用二级缓存，二级缓存是跨SqlSession的</p></blockquote><h3 id="2-一级缓存"><a href="#2-一级缓存" class="headerlink" title="2.一级缓存"></a>2.一级缓存</h3><p>mybatis默认一级缓存是开启的</p><h4 id="2-1一级缓存介绍"><a href="#2-1一级缓存介绍" class="headerlink" title="2.1一级缓存介绍"></a>2.1一级缓存介绍</h4><blockquote><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/2.PNG" style="zoom: 200%;"></blockquote><blockquote><p>rowBounds是一个分页对象</p><p>结论：1、第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从 数据 库查询用户信息。得到                  用户信息，将用户信息存储到一级缓存中。</p><p>​           2、 如果中间sqlSession去执行commit操作（执行插入、更新、删除），则会清空SqlSession中的 一 级缓存，这样做的目的                                     为了让缓存中存储的是最新的信息，避免脏读。</p><p>​           3、 第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直 接从 缓存中获取用户信息</p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/3.PNG"></p></blockquote><h4 id="2-2一级缓存原理与源码分析"><a href="#2-2一级缓存原理与源码分析" class="headerlink" title="2.2一级缓存原理与源码分析"></a>2.2一级缓存原理与源码分析</h4><p>问题：</p><p>一级缓存到底是什么？就是一个hashmap</p><p>一级缓存什么时候被创建？Executor的createCacheKey</p><p>一级缓存的工作流程是怎样的？</p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/6.PNG"></p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/4.PNG"></p><blockquote><p>​    流程走到Perpetualcache中的clear()方法之后，会调用其cache.clear()方法，那 么这个 cache是什么东西呢？点进去发现，cache其实就是private Map cache = new HashMap()；也就是一个Map，所以说cache.clear()其实就是map.clear()，也就是说，缓存其实就是 本地存放的一个map对象，每一个SqISession都会存放一个map对象的引用</p><p>cache是何 时创 建的呢？</p><p>我觉得是Executor，为什么这么认为？因为Executor是 执行器，用来执行SQL请求，而且清除缓存的方法也在Executor中执行，所以很可能缓存的创建也很有可能在Executor中，看了一圈发现Executor中有一个createCacheKey方法，这个方法很像是创建缓存的 方法啊，跟进去看看，你发现createCacheKey方法是由BaseExecutor执行的</p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/5.PNG"></p><p>如果查不到的话，就从数据库查，在queryFromDatabase中，会对localcache进行写入。 localcache 对象的put方法最终交给Map进行存放</p></blockquote><h3 id="2-二级缓存"><a href="#2-二级缓存" class="headerlink" title="2.二级缓存"></a>2.二级缓存</h3><h4 id="2-1二级缓存介绍"><a href="#2-1二级缓存介绍" class="headerlink" title="2.1二级缓存介绍"></a>2.1二级缓存介绍</h4><p>二级缓存的原理和一级缓存原理一样，第一次查询，会将数据放入缓存中，然后第二次查询则会直接去 缓存中取。但是一级缓存是基于sqlSession的，而二级缓存是基于mapper文件的namespace的，也 就 是说多个sqlSession可以共享一个mapper中的二级缓存区域，并且如果两个mapper的namespace 相 同，即使是两个mapper,那么这两个mapper中执行sql查询到的数据也将存在相同的二级缓存区域 中.</p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/7.PNG"></p><blockquote><p>如何使用二级缓存 </p><p>① 、开启二级缓存 和一级缓存默认开启不一样，二级缓存需要我们手动开启 首先在全局配置文件sqlMapConfig.xml文件中加入如下代码:</p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/8.PNG"></p><p>其次在UserMapper.xml文件中开启缓存:</p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/9.PNG"></p><p>以上是基于xml的开启二级缓存，如果是基于注解开发，</p><p>则需要在当前mapper接口类上面加上注解：@CacheNamespace</p><p>二级缓存缓存的不是对象，而是对象里面的数据</p><p>二级缓存底层还是HashMap结构</p><p>开启了二级缓存后，还需要将要缓存的pojo实现Serializable接口，为了将缓存数据取出执行反序列化操作，因为二级缓存数据存储介质多种多样，不一定只存在内存中，有可能存在硬盘中，如果我们要再 取 这个缓存的话，就需要反序列化了。所以mybatis中的pojo都去实现Serializable接口</p><p>useCache和flushCache：</p><p>mybatis中还可以配置userCache和flushCache等配置项，userCache是用来设置是否禁用二级缓 存 的，在statement中设置useCache=false可以禁用当前select语句的二级缓存，即每次查询都会发出 sql 去查询，默认情况是true,即该sql使用二级缓存</p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/10.PNG"></p><p>这种情况是针对每次查询都需要最新的数据sql,要设置成useCache=false，禁用二级缓存，直接从数 据 库中获取。 在mapper的同一个namespace中，如果有其它insert、update, delete操作数据后需要刷新缓 存，如 果不执行刷新缓存会出现脏读。 设置statement配置中的flushCache=”true”属性，默认情况下为true,即刷新缓存，如果改成false则 不 会刷新。使用缓存时如果手动修改数据库表中的查询数据会出现脏读。</p><p>一般下执行完commit操作都需要刷新缓存，flushCache=true表示刷新缓存，这样可以避免数据库脏 读。所以我们不用设置，默认即可</p></blockquote><blockquote><p>开启二级缓存的具体写法</p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/11.PNG"></p></blockquote><h4 id="2-2使用redis实现二级缓存"><a href="#2-2使用redis实现二级缓存" class="headerlink" title="2.2使用redis实现二级缓存"></a>2.2使用redis实现二级缓存</h4><p>问题：为什么选择redis实现二级缓存而不选择mybatis自己的缓存？</p><blockquote><p>分析： mybatis自带的二级缓存，但是这个缓存是单服务器工作，无法实现分布式缓存。 那么 什么是分布式缓存呢？假设现在有两个服务器1和2,用户访问的时候访问了 1服务器，查询后的缓 存就 会放在1服务器上，假设现在有个用户访问的是2服务器，那么他在2服务器上就无法获取刚刚那 缓存，如下图所示：</p></blockquote><blockquote><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/12.PNG"></p><p>为了解决这个问题，就得找一个分布式的缓存，专门用来存储缓存数据的，这样不同的服务器要缓存数 据都往它那里存，取缓存数据也从它那里取，如下图所示：</p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/13.PNG"></p></blockquote><p>如上图所示，在几个不同的服务器之间，我们使用第三方缓存框架，将缓存都放在这个第三方框架中, 然后无论有多少台服务器，我们都能从缓存中获取数据。</p><p>2.3 mybatis与redis的整合</p><p>实现步骤：</p><p>1.导入jar包</p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/14.PNG"></p><p>2.配置文件</p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/16.PNG"></p><p>或者在当前接口处添加配置：</p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/17.PNG"></p><p>3.配置redis文件</p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/18.PNG"></p><h4 id="2-3redisCache源码分析"><a href="#2-3redisCache源码分析" class="headerlink" title="2.3redisCache源码分析"></a>2.3redisCache源码分析</h4><p>问题：</p><blockquote><p>redisCache是如何向redis进行缓存值得存取？</p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/21.PNG"></p><p>解析redis.properties文件</p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/19.PNG"></p></blockquote><blockquote><p>当前用到得到是redis中的那种结构？—hash</p><p><img src="/2020/12/07/shen-ru-li-jie-mybatis-de-huan-cun-ji-zhu/20.PNG"></p></blockquote><p>核心类 RedisCache   </p><p>redisCache是在mybatis进行初始化的时候就进行创建了，执行RedisCache的有参构造</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解mybatis复杂映射</title>
      <link href="/2020/12/06/shen-ru-li-jie-mybatis-fu-za-ying-she/"/>
      <url>/2020/12/06/shen-ru-li-jie-mybatis-fu-za-ying-she/</url>
      
        <content type="html"><![CDATA[<p>1.配置映射</p><blockquote><p>一对一：实现业务 查询一个订单，于此同时查询出该订单所属的用户信息</p><p>sql：select *from orders o,user u where o.uid =u.id</p></blockquote><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-fu-za-ying-she/1.png"></p><p>问题分析：</p><p>resultType：mybatis自定按照字段名和属性名完成映射封装，但是user在order表中无法完成映射</p><p>解决方案：</p><p>resultMap：手动配置实体属性与表字段的映射关系</p><p>方法一：</p><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-fu-za-ying-she/2.png"></p><p>方法二：</p><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-fu-za-ying-she/4.png"></p><p>引入映射文件</p><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-fu-za-ying-she/5.png"></p><blockquote><p>配置文件所在的包必须和mapper接口所在的包一致</p></blockquote><blockquote><p>一对多：实现业务 查询全部用户 于此同时查询出每个用户具有的订单信息    </p><p>业务分析：查询出所有的用户 没有关联订单信息的用户也需要查询出来   因此要使用外连接，不能使用内连接</p><p>select *,o.id oid from user u left join orders o on u.id=o.uid;</p><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-fu-za-ying-she/6.png"></p></blockquote><blockquote><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-fu-za-ying-she/7.png"></p></blockquote><blockquote><p>多对多: 业务  查询用户同时查询出该用户的所有角色</p><p>业务分析：一个用户对应多个角色，一个角色被多个用户使用 </p><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-fu-za-ying-she/8.png"></p></blockquote><blockquote><p>sql:：select u.,r.,r.id rid from user u left join user_role ur on u.id=ur.user_id inner join role r on ur.role_id=r.id;</p><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-fu-za-ying-she/9.png"></p></blockquote><blockquote><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-fu-za-ying-she/10.png"></p></blockquote><p>2.注解crud</p><p>mybatis常用注解</p><blockquote><p> @Insert：实现新增</p><p> @Update：实现更新</p><p> @Delete：实现删除</p><p> @Select：实现查询</p><p> @Result：实现结果集封装</p><p> @Results：可以与</p><p> @Result 一起使用，封装多个结果集 </p><p> @One：实现一对一结果集封装 </p><p> @Many：实现一对多结果集封装</p></blockquote><p>增删改查注解实现</p><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-fu-za-ying-she/11.png"></p><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-fu-za-ying-she/12.png"></p><p>引入配置文件的方式</p><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-fu-za-ying-she/13.png">3.注解映射</p><p>@Results注解</p><p>@Result注解</p><p>@One注解</p><p>@Many</p><blockquote><p>一对一</p><p>sql:select * from orders; </p><p>​      select * from user where id=查询出订单的uid;</p><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-fu-za-ying-she/14.png"></p></blockquote><blockquote><p>一对多</p><p>sql:select * from user;</p><p>​      select * from orders where uid=查询出用户的id;</p><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-fu-za-ying-she/15.png"></p></blockquote><blockquote><p>多对多</p><p>sql:select * from user;</p><p>​      select * from role r,user_role ur where r.id=ur.role_id and ur.user_id=用户的id</p><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-fu-za-ying-she/16.png"></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解mybatis的配置文件</title>
      <link href="/2020/12/06/shen-ru-li-jie-mybatis-de-pei-zhi-wen-jian/"/>
      <url>/2020/12/06/shen-ru-li-jie-mybatis-de-pei-zhi-wen-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="1-SqlMapConfig-xml文件"><a href="#1-SqlMapConfig-xml文件" class="headerlink" title="1.SqlMapConfig.xml文件"></a>1.SqlMapConfig.xml文件</h3><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-de-pei-zhi-wen-jian/1.png"></p><p>mybatis常用标签解析</p><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-de-pei-zhi-wen-jian/2.png"></p><p>事务管理器（transactionManager）类型：</p><blockquote><p>JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作 用域。</p><p>MANAGED：它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。</p></blockquote><p>数据源（dataSource）类型有三种：</p><blockquote><p>UNPOOLED：每次被请求时打开和关闭连接。</p><p>POOLED：使用mybatis提供的连接池。</p><p>JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配 置数据源，然后放置一个 JNDI 上下文的引用。</p></blockquote><p>mapper标签</p><blockquote><p>使用相对于类路径的资源引用，例如：</p><mapper resource="org/mybatis/builder/AuthorMapper.xml"><p>使用完全限定资源定位符（URL），例如：</p> <mapper url="file:///var/mappers/AuthorMapper.xml"><p>使用映射器接口实现类的完全限定类名，例如：</p><mapper class="org.mybatis.builder.AuthorMapper"><p>将包内的映射器接口实现全部注册为映射器，例如：</p><package name="org.mybatis.builder"></package></mapper></mapper></mapper></blockquote><p>properties标签</p><blockquote><p>实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的 properties文件</p></blockquote><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-de-pei-zhi-wen-jian/3.png"></p><p>typeAliases标签</p><p>给全限定类名起别名。原来的类型名称配置如下</p><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-de-pei-zhi-wen-jian/4.png"></p><blockquote><p>上面的情况只适合给单独的实体起别名，当有很多的实体类时，我们可以采用：</p><p><package name="包名">  批量起别名  ：该包下所有的类的本身的别名，别名不区分大小写</package></p></blockquote><p>上面是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名</p><h3 id="2-mapper-xml文件"><a href="#2-mapper-xml文件" class="headerlink" title="2.mapper.xml文件"></a><img src="/2020/12/06/shen-ru-li-jie-mybatis-de-pei-zhi-wen-jian/5.png">2.mapper.xml文件</h3><p>Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是 动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。</p><h4 id="2-1动态sql–-gt-if-多条件组合查询"><a href="#2-1动态sql–-gt-if-多条件组合查询" class="headerlink" title="2.1动态sql–>if    多条件组合查询"></a>2.1动态sql–&gt;if    多条件组合查询</h4><p>根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查 询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。</p><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-de-pei-zhi-wen-jian/6.png"></p><h4 id="2-2动态sql–-gt-foreach"><a href="#2-2动态sql–-gt-foreach" class="headerlink" title="2.2动态sql–>foreach"></a>2.2动态sql–&gt;foreach</h4><p>循环执行sql的拼接操作    例如：SELECT * FROM USER WHERE id IN (1,2,5)。</p><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-de-pei-zhi-wen-jian/7.png"></p><blockquote><p>open拼接的是条件的开始部分   </p><p>close是条件的结束部分 </p><p>item接收当前遍历出来的值</p><p>separator定义分隔符     </p></blockquote><p>sql片段的抽取 ：Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的</p><p><img src="/2020/12/06/shen-ru-li-jie-mybatis-de-pei-zhi-wen-jian/8.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义持久层框架</title>
      <link href="/2020/12/05/zi-ding-yi-chi-jiu-ceng-kuang-jia/"/>
      <url>/2020/12/05/zi-ding-yi-chi-jiu-ceng-kuang-jia/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义持久层框架"><a href="#自定义持久层框架" class="headerlink" title="自定义持久层框架"></a>自定义持久层框架</h1><h3 id="1-对JDBC的操作问题进行分析"><a href="#1-对JDBC的操作问题进行分析" class="headerlink" title="1.对JDBC的操作问题进行分析"></a>1.对JDBC的操作问题进行分析</h3><p>jdbc的代码：</p><pre class=" language-shell"><code class="language-shell">public static void main(String[] args) &#123;        Connection connection = null;        PreparedStatement preparedStatement = null;        ResultSet resultSet = null;        try &#123;            // 加载数据库驱动            Class.forName("com.mysql.jdbc.Driver");            // 通过驱动管理类获取数据库链接            connection =                    DriverManager.getConnection("jdbc:mysql://localhost:3306/mybatis?                            characterEncoding=utf-8", "root", "root");                            // 定义sql语句？表示占位符                            String sql = "select * from user where username = ?";            // 获取预处理statement            preparedStatement = connection.prepareStatement(sql);            // 设置参数，第一个参数为sql语句中参数的序号(从1开始)，第二个参数为设置的参数值            preparedStatement.setString(1, "tom");            // 向数据库发出sql执行查询，查询出结果集            resultSet = preparedStatement.executeQuery();            // 遍历查询结果集            while (resultSet.next()) &#123;                int id = resultSet.getInt("id");                String username = resultSet.getString("username");                // 封装User                user.setId(id);                user.setUsername(username);            &#125;            System.out.println(user);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125; finally &#123;        // 释放资源        if (resultSet != null) &#123;            try &#123;                resultSet.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (preparedStatement != null) &#123;            try &#123;                preparedStatement.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (connection != null) &#123;            try &#123;                connection.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;</code></pre><h4 id="1-1-JDBC问题分析"><a href="#1-1-JDBC问题分析" class="headerlink" title="1.1.JDBC问题分析"></a>1.1.JDBC问题分析</h4><p>原始jdbc开发存在的问题如下： </p><blockquote><p>1、数据库配置信息存在硬编码；</p><p>2、频繁创建释放数据库连接,浪费系统资源</p><p>3、sql语句、设置参数获取结果集参数均存在硬编码问题</p><p>4、手动封装返回结果集，较为繁琐</p></blockquote><h4 id="1-2问题解决思路"><a href="#1-2问题解决思路" class="headerlink" title="1.2问题解决思路"></a>1.2问题解决思路</h4><blockquote><p>1.使用数据库连接池初始化连接资源 </p><p>2.将sql语句抽取到xml配置文件中 </p><p>3.使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射</p></blockquote><h3 id="2-自定义框架设计"><a href="#2-自定义框架设计" class="headerlink" title="2.自定义框架设计"></a>2.自定义框架设计</h3><h6 id="客户端：引入自定义持久层框架的jar包"><a href="#客户端：引入自定义持久层框架的jar包" class="headerlink" title="客户端：引入自定义持久层框架的jar包"></a>客户端：引入自定义持久层框架的jar包</h6><blockquote><p>提供两部分配置信息：数据库配置信息、sql配置信息：（sql语句、参数类型、返回值类型）</p></blockquote><blockquote><p>使用配置文件来提供这两部分信息:</p><p>(1)、sqlMapConfig.xml：存放数据库配置信息，再存放mapper.xml的全路径</p><p>(2)、mapper.xml：存放sql配置信息</p></blockquote><h6 id="自定义持久层框架：本质就是对JDBC代码的封装"><a href="#自定义持久层框架：本质就是对JDBC代码的封装" class="headerlink" title="自定义持久层框架：本质就是对JDBC代码的封装"></a>自定义持久层框架：本质就是对JDBC代码的封装</h6><blockquote><p>（1）、加载配置文件 : 根据配置文件的路径，加载配置文件成字节输入流，存储在内存中</p><p>​              创建Resources类 方法：InputStream getResourceAsStream（String path ）</p><p>（2）、创建两个javaBean：（容器对象）：存放的就是配置文件解析出来的内容</p><p>​              Configuration：核心配置类：存放sqlMapCongfig解析出来的内容</p><p>​              MappedStatement：映射配置类：存放的就是mapper.xml中解析出来的内容        </p><p>（3）、解析配置文件 dom4j</p><p>​              创建类：SqlSessionFactoryBuilder 方法：build（InputStream in）</p><p>​              第一：使用dom4j解析配置文件，将解析出来的内容封装到容器对象中</p><p>​              第二：创建SqlSessionFactory对象：生产sqlSession：会话对象（工厂模式）</p><p>（4）、基于开闭原则创建sqlSessionFactory接口及实现类DefaultSqlSessionFactory</p><p>​              第一：openSession（）：生产sqlSession </p><p>（5）、创建SqlSession接口及实现类DefaultSession</p><p>​              定义对数据库的crud操作：selectList（）</p><p>​                                                            selectOne（）</p><p>​                                                            update（）</p><p>​                                                            delete（）</p><p>（6）、创建Executor接口及实现类SimpleExecutor实现类</p><p>​             方法 query（Configuration，MappedStatement，Object… params）执行的就是JDBC代码</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdbc与mybatis</title>
      <link href="/2020/12/02/jdbc-yu-mybatis/"/>
      <url>/2020/12/02/jdbc-yu-mybatis/</url>
      
        <content type="html"><![CDATA[<h4 id="1-ORM"><a href="#1-ORM" class="headerlink" title="1.ORM"></a>1.ORM</h4><ul><li><p>ORM(Object Relational Mapping)： 对象关系映射</p></li><li><p>指的是持久化数据和实体对象的映射模式，为了解决面向对象与关系型数据库存在的互不匹配的现象的技术。</p></li></ul><p><img src="/2020/12/02/jdbc-yu-mybatis/1.jpg"></p><h4 id="2-原始jdbc操作（查询数据）"><a href="#2-原始jdbc操作（查询数据）" class="headerlink" title="2.原始jdbc操作（查询数据）"></a>2.原始jdbc操作（查询数据）</h4><p><img src="/2020/12/02/jdbc-yu-mybatis/2.jpg"></p><h4 id="3-原始jdbc操作（插入数据）"><a href="#3-原始jdbc操作（插入数据）" class="headerlink" title="3.原始jdbc操作（插入数据）"></a>3.原始jdbc操作（插入数据）</h4><p><img src="/2020/12/02/jdbc-yu-mybatis/3.jpg"></p><h4 id="4-原始jdbc操作的分析"><a href="#4-原始jdbc操作的分析" class="headerlink" title="4.原始jdbc操作的分析"></a>4.原始jdbc操作的分析</h4><ul><li><p>原始 JDBC 的操作问题分析 </p><p>​    1.频繁创建和销毁数据库的连接会造成系统资源浪费从而影响系统性能。</p><pre><code>2. sql 语句在代码中硬编码，如果要修改 sql 语句，就需要修改 java 代码，造成代码不易维护。3. 查询操作时，需要手动将结果集中的数据封装到实体对象中。4. 增删改查操作需要参数时，需要手动将实体对象的数据设置到 sql 语句的占位符。 </code></pre></li><li><p>原始 JDBC 的操作问题解决方案 </p><p>​    1.使用数据库连接池初始化连接资源。 </p><ol start="2"><li>将 sql 语句抽取到配置文件中。 </li><li>使用反射、内省等底层技术，将实体与表进行属性与字段的自动映射    </li></ol></li></ul><blockquote><p>mybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</p></blockquote><blockquote><p>mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。</p></blockquote><blockquote><p>最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。</p></blockquote><h4 id="5-MyBatis开发步骤："><a href="#5-MyBatis开发步骤：" class="headerlink" title="5.MyBatis开发步骤："></a>5.MyBatis开发步骤：</h4><p>①添加MyBatis的jar包</p><p>②创建Student数据表</p><p>③编写Studentr实体类 </p><p>④编写映射文件StudentMapper.xml</p><p>⑤编写核心文件MyBatisConfig.xml</p><p>⑥编写测试类</p><p>6.映射文件编写（StudentMapper.xml）</p><!--?xml version="1.0" encoding="UTF-8" ?--><!--MyBatis的DTD约束--><!--    mapper：核心根标签    namespace属性：名称空间--><mapper namespace="StudentMapper">    <!--        select：查询功能的标签        id属性：唯一标识        resultType属性：指定结果映射对象类型        parameterType属性：指定参数映射对象类型    --><pre><code>&lt;select id="selectAll" resultType="student"&gt;    SELECT * FROM student&lt;/select&gt;</code></pre></mapper><p>7.核心文件编写</p><!--?xml version="1.0" encoding="UTF-8" ?--><!--MyBatis的DTD约束--><!--configuration 核心根标签--><configuration><pre><code>&lt;!--引入数据库连接的配置文件--&gt;&lt;properties resource="jdbc.properties"/&gt;&lt;!--配置LOG4J--&gt;&lt;settings&gt;    &lt;setting name="logImpl" value="log4j"/&gt;&lt;/settings&gt;&lt;!--起别名--&gt;&lt;typeAliases&gt;    &lt;typeAlias type="com.itheima.bean.Student" alias="student"/&gt;    &lt;!--&lt;package name="com.itheima.bean"/&gt;--&gt;&lt;/typeAliases&gt;&lt;!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个--&gt;&lt;environments default="mysql"&gt;    &lt;!--environment配置数据库环境  id属性唯一标识--&gt;    &lt;environment id="mysql"&gt;        &lt;!-- transactionManager事务管理。  type属性，采用JDBC默认的事务--&gt;        &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt;        &lt;!-- dataSource数据源信息   type属性 连接池--&gt;        &lt;dataSource type="POOLED"&gt;            &lt;!-- property获取数据库连接的配置信息 --&gt;            &lt;property name="driver" value="${driver}" /&gt;            &lt;property name="url" value="${url}" /&gt;            &lt;property name="username" value="${username}" /&gt;            &lt;property name="password" value="${password}" /&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;&lt;!-- mappers引入映射配置文件 --&gt;&lt;mappers&gt;    &lt;!-- mapper 引入指定的映射配置文件   resource属性指定映射配置文件的名称 --&gt;    &lt;mapper resource="StudentMapper.xml"/&gt;&lt;/mappers&gt;</code></pre></configuration><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot和canal集成包的安装</title>
      <link href="/2020/12/01/springboot-he-canal-ji-cheng-bao-de-an-zhuang/"/>
      <url>/2020/12/01/springboot-he-canal-ji-cheng-bao-de-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>当用户执行数据库的操作的时候，binlog 日志会被canal捕获到，并解析出数据。我们就可以将解析出来的数据进行相应的逻辑处理。</p><p>我们这里使用的一个开源的项目，它实现了springboot与canal的集成。比原生的canal更加优雅。</p><p>使用前需要将starter-canal安装到本地仓库。</p><p>安装步骤</p><h4 id="1-打开链接"><a href="#1-打开链接" class="headerlink" title="1.打开链接"></a>1.打开链接</h4><p><a href="https://github.com/chenqian56131/spring-boot-starter-canal">https://github.com/chenqian56131/spring-boot-starter-canal</a></p><h4 id="2-下载压缩包到本地并解压"><a href="#2-下载压缩包到本地并解压" class="headerlink" title="2.下载压缩包到本地并解压"></a>2.下载压缩包到本地并解压</h4><p><img src="/2020/12/01/springboot-he-canal-ji-cheng-bao-de-an-zhuang/1.jpg"></p><h4 id="3-解压文件后找到对应的目录"><a href="#3-解压文件后找到对应的目录" class="headerlink" title="3.解压文件后找到对应的目录"></a>3.解压文件后找到对应的目录</h4><p><img src="/2020/12/01/springboot-he-canal-ji-cheng-bao-de-an-zhuang/2.jpg"></p><h4 id="4-在当前目录打开cmd窗口输入命令："><a href="#4-在当前目录打开cmd窗口输入命令：" class="headerlink" title="4.在当前目录打开cmd窗口输入命令："></a>4.在当前目录打开cmd窗口输入命令：</h4><p>mvn clean install -DskipTests   安装到本地仓库，并跳过测试</p><p><img src="/2020/12/01/springboot-he-canal-ji-cheng-bao-de-an-zhuang/3.jpg"></p><h4 id="5-完成安装"><a href="#5-完成安装" class="headerlink" title="5.完成安装"></a>5.完成安装</h4><p><img src="/2020/12/01/springboot-he-canal-ji-cheng-bao-de-an-zhuang/4.jpg"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> canal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx限流</title>
      <link href="/2020/11/30/nginx-xian-liu/"/>
      <url>/2020/11/30/nginx-xian-liu/</url>
      
        <content type="html"><![CDATA[<p>nginx限流的方式</p><p>一般情况下，首页的并发量是比较大的，即使有了多级缓存，如果有大量恶意的请求，也会对系统造成影响。而限流就是保护措施之一。</p><p>nginx提供两种限流的方式：</p><ul><li>一是控制速率</li><li>二是控制并发连接数</li></ul><h3 id="1-控制速率"><a href="#1-控制速率" class="headerlink" title="1.控制速率"></a>1.控制速率</h3><p>控制速率的方式之一就是采用漏桶算法。</p><h4 id="1-1漏桶算法实现控制速率限流"><a href="#1-1漏桶算法实现控制速率限流" class="headerlink" title="1.1漏桶算法实现控制速率限流"></a>1.1漏桶算法实现控制速率限流</h4><p>漏桶(Leaky Bucket)算法思路很简单,水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率.示意图如下:</p><p><img src="/2020/11/30/nginx-xian-liu/1.jpg"></p><p>漏桶算法实现 nginx的配置</p><p>配置示意图如下：</p><p><img src="/2020/11/30/nginx-xian-liu/2.jpg"></p><p>修改/usr/local/openresty/nginx/conf/nginx.conf:</p><pre><code>#user  nobody;user root root;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events &amp;#123;    worker_connections  1024;&amp;#125;http &amp;#123;    include       mime.types;    default_type  application/octet-stream;    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '    #                  '$status $body_bytes_sent "$http_referer" '    #                  '"$http_user_agent" "$http_x_forwarded_for"';    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    limit_req_zone $binary_remote_addr zone=myRateLimit:10m rate=2r/s;    server &amp;#123;          listen       8081;        server_name  localhost;        charset utf-8;        location / &amp;#123;            limit_req zone=myRateLimit;            root   html;            index  index.html index.htm;        &amp;#125;    &amp;#125;&amp;#125;</code></pre><p>解释：</p><pre><code>binary_remote_addr 是一种key，表示基于 remote_addr(客户端IP) 来做限流，binary_ 的目的是压缩内存占用量。zone：定义共享内存区来存储访问信息， myRateLimit:10m 表示一个大小为10M，名字为myRateLimit的内存区域。1M能存储16000 IP地址的访问信息，10M可以存储16W IP地址访问信息。rate 用于设置最大访问速率，rate=10r/s 表示每秒最多处理10个请求。Nginx 实际上以毫秒为粒度来跟踪请求信息，因此 10r/s 实际上是限制：每100毫秒处理一个请求。这意味着，自上一个请求处理完后，若后续100毫秒内又有请求到达，将拒绝处理该请求.我们这里设置成2 方便测试。</code></pre><p>测试：重新加载配置文件</p><pre><code>cd /usr/local/openresty/nginx/sbin./nginx -s reload</code></pre><p>访问页面： 直接报错。拒绝访问。</p><p><img src="/2020/11/30/nginx-xian-liu/3.jpg"></p><h4 id="1-2-处理突发流量"><a href="#1-2-处理突发流量" class="headerlink" title="1.2 处理突发流量"></a>1.2 处理突发流量</h4><p>上面例子限制 2r/s，如果有时正常流量突然增大，超出的请求将被拒绝，无法处理突发流量，可以结合 <strong>burst</strong> 参数使用来解决该问题。</p><p>例如，如下配置表示：</p><pre><code>server &amp;#123;    location / &amp;#123;        limit_req zone=myRateLimit burst=5;        root   html;        index  index.html index.htm;    &amp;#125;&amp;#125;</code></pre><p>burst 译为突发、爆发，表示在超过设定的处理速率后能额外处理的请求数,当 rate=2r/s 时，将1s拆成2份，即每500ms可处理1个请求。</p><p>此处，<strong>burst=5</strong> ，若同时有6个请求到达，Nginx 会处理第一个请求，剩余5个请求将放入队列，然后每隔500ms从队列中获取一个请求进行处理。若请求数大于6，将拒绝处理多余的请求，直接返回503.</p><p>不过，单独使用 burst 参数并不实用。假设 burst=50 ，rate为10r/s，排队中的50个请求虽然每100ms会处理一个，但第50个请求却需要等待 50 * 100ms即 5s，这么长的处理时间自然难以接受。</p><p>因此，burst 往往结合 nodelay 一起使用。</p><p>例如：如下配置：</p><pre><code>server &amp;#123;    location / &amp;#123;        limit_req zone=myRateLimit burst=5 nodelay;        root   html;        index  index.html index.htm;    &amp;#125;&amp;#125;</code></pre><p>如上表示：</p><p>处理突发5个请求的时候，没有延迟，等到完成之后，按照正常的速率处理。</p><p>如上两种配置结合就达到了速率稳定，但突然流量也能正常处理的效果。配置代码如下：</p><pre><code>#user  nobody;user root root;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events &amp;#123;    worker_connections  1024;&amp;#125;http &amp;#123;    include       mime.types;    default_type  application/octet-stream;    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '    #                  '$status $body_bytes_sent "$http_referer" '    #                  '"$http_user_agent" "$http_x_forwarded_for"';    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    # 设置限流配置    limit_req_zone $binary_remote_addr zone=myRateLimit:10m rate=2r/s;    server &amp;#123;          listen       8081;        server_name  localhost;        charset utf-8;        location / &amp;#123;            limit_req zone=myRateLimit burst = 5 nodelay;            root   html;            index  index.html index.htm;        &amp;#125;    &amp;#125;&amp;#125;</code></pre><p>测试：如下图 在1秒钟之内可以刷新5次，正常处理。</p><p><img src="/2020/11/30/nginx-xian-liu/4.jpg"></p><p>但是超过之后，连续刷新5次，抛出异常。</p><p><img src="/2020/11/30/nginx-xian-liu/5.jpg"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存预热+二级缓存查询</title>
      <link href="/2020/11/30/huan-cun-yu-re-er-ji-huan-cun-cha-xun/"/>
      <url>/2020/11/30/huan-cun-yu-re-er-ji-huan-cun-cha-xun/</url>
      
        <content type="html"><![CDATA[<h3 id="1-实现缓存预热和二级缓存查询"><a href="#1-实现缓存预热和二级缓存查询" class="headerlink" title="1.实现缓存预热和二级缓存查询"></a>1.实现缓存预热和二级缓存查询</h3><p>步骤一：编写lua脚本实现缓存预热（将mysql里的数据查询出来存入redis）</p><p><img src="/2020/11/30/huan-cun-yu-re-er-ji-huan-cun-cha-xun/1.jpg"></p><p>步骤二：编写lua脚本实现二级缓存读取</p><p><img src="/2020/11/30/huan-cun-yu-re-er-ji-huan-cun-cha-xun/2.jpg"></p><h3 id="2-代码实现缓存预热"><a href="#2-代码实现缓存预热" class="headerlink" title="2.代码实现缓存预热"></a>2.代码实现缓存预热</h3><p>实现思路：</p><p>定义请求：用于查询数据库中的数据更新到redis中。</p><p>（1）连接mysql ，按照广告分类ID读取广告列表，转换为json字符串。</p><p>（2）连接redis，将广告列表json字符串存入redis 。</p><p>定义请求：</p><pre class=" language-shell"><code class="language-shell">请求：    /ad_update参数：    position  --指定广告位置返回值：    json</code></pre><p>在/root/lua目录下创建ad_load.lua ，实现连接mysql 查询数据 并存储到redis中。</p><pre class=" language-shell"><code class="language-shell">ngx.header.content_type="application/json;charset=utf8"local cjson = require("cjson")local mysql = require("resty.mysql")local uri_args = ngx.req.get_uri_args()local position = uri_args["position"]local db = mysql:new()db:set_timeout(1000)  local props = &#123;      host = "192.168.200.128",      port = 3306,      database = "changgou_business",      user = "root",      password = "root"  &#125;local res = db:connect(props)  local select_sql = "select url,image from tb_ad where status ='1' and position='"..position.."' and start_time<= NOW() AND end_time>= NOW()"  res = db:query(select_sql)  db:close()  local redis = require("resty.redis")local red = redis:new()red:set_timeout(2000)local ip ="192.168.200.128"local port = 6379red:connect(ip,port)red:set("ad_"..position,cjson.encode(res))red:close()ngx.say("&#123;flag:true&#125;")</code></pre><p>修改/usr/local/openresty/nginx/conf/nginx.conf文件：</p><p>代码如下：</p><pre class=" language-shell"><code class="language-shell">#user  nobody;user root root;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    server &#123;        listen       80;        server_name  localhost;        charset utf-8;        #access_log  logs/host.access.log  main;        # 添加        location /ad_update &#123;            content_by_lua_file /root/lua/ad_update.lua;        &#125;        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root   html;        &#125;            &#125;&#125;</code></pre><p>重新启动nginx</p><p>测试：<a href="http://192.168.200.128/ad_update?position=web_index_lb">http://192.168.200.128/ad_update?position=web_index_lb</a></p><h3 id="3-代码实现缓存读取"><a href="#3-代码实现缓存读取" class="headerlink" title="3.代码实现缓存读取"></a>3.代码实现缓存读取</h3><p>实现思路：</p><p>通过lua脚本直接从redis中获取数据即可。</p><p>定义请求：</p><pre class=" language-shell"><code class="language-shell">请求:/ad_read参数：position返回值：json</code></pre><p>在/root/lua目录下创建ad_read.lua</p><pre class=" language-shell"><code class="language-shell">ngx.header.content_type="application/json;charset=utf8"local uri_args = ngx.req.get_uri_args();local position = uri_args["position"];local redis = require("resty.redis");local red = redis:new()red:set_timeout(2000)local ok, err = red:connect("192.168.200.128", 6379)local rescontent=red:get("ad_"..position)ngx.say(rescontent)red:close()</code></pre><p>在/usr/local/openresty/nginx/conf/nginx.conf中server下添加配置</p><pre class=" language-shell"><code class="language-shell">location /ad_read &#123;  content_by_lua_file /root/lua/ad_read.lua;&#125;</code></pre><p>测试 <a href="http://192.168.200.128/ad_read?position=web_index_lb">http://192.168.200.128/ad_read?position=web_index_lb</a> 输出</p><pre><code>[&amp;#123;"url":"img\/banner1.jpg","image":"img\/banner1.jpg"&amp;#125;,&amp;#123;"url":"img\/banner2.jpg","image":"img\/banner2.jpg"&amp;#125;]</code></pre><h3 id="4-二级缓存-加入openresty本地缓存"><a href="#4-二级缓存-加入openresty本地缓存" class="headerlink" title="4.二级缓存-加入openresty本地缓存"></a>4.二级缓存-加入openresty本地缓存</h3><p>如上的方式没有问题，但是如果请求都到redis，redis压力也很大，所以我们一般采用多级缓存的方式来减少下游系统的服务压力。</p><p>先查询openresty本地缓存 如果没有再查询redis中的数据</p><ul><li>修改/root/lua目录下ad_read文件, 内容如下:</li></ul><pre class=" language-shell"><code class="language-shell">ngx.header.content_type="application/json;charset=utf8"local uri_args = ngx.req.get_uri_args();local position = uri_args["position"];local cache_ngx = ngx.shared.dis_cache;local adCache = cache_ngx:get('ad_cache_'..position);if adCache == "" or adCache == nil then    local redis = require("resty.redis");    local red = redis:new()    red:set_timeout(2000)    local ok, err = red:connect("192.168.200.128", 6379)    local rescontent=red:get("ad_"..position)    ngx.say(rescontent)    red:close()    cache_ngx:set('ad_cache_'..position, rescontent, 10*60);else    ngx.say(adCache)end</code></pre><ul><li>修改nginx配置文件vi /usr/local/openresty/nginx/conf/nginx.conf ，http节点下添加配置:</li></ul><pre class=" language-shell"><code class="language-shell">#包含redis初始化模块lua_shared_dict dis_cache 5m;  #共享内存开启</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx的三大功能</title>
      <link href="/2020/11/29/nginx-de-san-da-gong-neng/"/>
      <url>/2020/11/29/nginx-de-san-da-gong-neng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一个单机的Tomcat理论上最多能承载500个并发，Tomcat集群内部最多5个服务器，超过5个对于整个Tomcat服务器的性能来说是不升反降的</p></blockquote><blockquote><p>单机的Nginx能够承载的最大并发量是50000</p></blockquote><h3 id="1-负载均衡功能"><a href="#1-负载均衡功能" class="headerlink" title="1.负载均衡功能"></a>1.负载均衡功能</h3><blockquote><p>nginx作为负载均衡器使用可以接收所有请求, 并将请求分发给tomcat集群服务器</p></blockquote><p><img src="/2020/11/29/nginx-de-san-da-gong-neng/1.jpg"></p><h3 id="2-反向代理功能"><a href="#2-反向代理功能" class="headerlink" title="2.反向代理功能"></a>2.反向代理功能</h3><blockquote><p>nginx作为反向代理服务器使用可以根据访问的url地址判断将请求发给哪个具体的服务器处理</p></blockquote><p><img src="/2020/11/29/nginx-de-san-da-gong-neng/2.jpg"></p><h3 id="3-http服务器功能"><a href="#3-http服务器功能" class="headerlink" title="3.http服务器功能"></a>3.http服务器功能</h3><blockquote><p>nginx作为http服务器可以运行静态资源, 包括html, css, js, 图片等, 效率比tomcat要高很多</p></blockquote><blockquote><p>静态资源可以放在nginx中的html文件夹下(一般系统首页, 商品详情页可以放在里面运行使用)</p></blockquote><p><img src="/2020/11/29/nginx-de-san-da-gong-neng/3.jpg"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lua基础知识总结</title>
      <link href="/2020/11/28/lua-ji-chu-zhi-shi-zong-jie/"/>
      <url>/2020/11/28/lua-ji-chu-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="1-lua是什么"><a href="#1-lua是什么" class="headerlink" title="1.lua是什么"></a>1.lua是什么</h3><p>Lua 是一个小巧的<a href="https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a>。 其设计目的是为了通过灵活嵌入应用程序中从而为应用程序提供灵活的扩展和定制功能。Lua由标准C编写而成，几乎在所有操作系统和平台上都可以编译，运行。Lua并没有提供强大的库，这是由它的定位决定的。所以Lua不适合作为开发独立应用程序的语言。Lua 有一个同时进行的JIT项目，提供在特定平台上的即时编译功能。</p><p>简单来说：</p><p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p><p><strong>lua 语言具有以下特性</strong></p><ul><li>支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；</li><li>自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；</li><li>语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；</li><li>通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。</li></ul><p><strong>应用场景</strong></p><ul><li>游戏开发</li><li>独立应用脚本</li><li>Web 应用脚本</li><li>扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench</li><li>安全系统，如入侵检测系统</li><li>redis中嵌套调用实现类似事务的功能</li><li>web容器中应用处理一些过滤 缓存等等的逻辑，例如nginx。</li></ul><h3 id="2-lua的安装"><a href="#2-lua的安装" class="headerlink" title="2.lua的安装"></a>2.lua的安装</h3><p>用linux版本的安装</p><pre class=" language-shell"><code class="language-shell">yum install -y gccyum install libtermcap-devel ncurses-devel libevent-devel readline-develcurl -R -O http://www.lua.org/ftp/lua-5.3.5.tar.gztar -zxf lua-5.3.5.tar.gzcd lua-5.3.5make linux testmake install</code></pre><h3 id="3-简单语句"><a href="#3-简单语句" class="headerlink" title="3.简单语句"></a>3.简单语句</h3><p>创建hello.lua文件，内容为</p><pre><code>print("hello");</code></pre><p>保存。执行命令</p><pre><code>lua helloworld.lua</code></pre><p>输出为：</p><pre><code>Hello</code></pre><h3 id="4-lua的基本语法"><a href="#4-lua的基本语法" class="headerlink" title="4.lua的基本语法"></a>4.lua的基本语法</h3><ul><li><p>lua有交互式编程和脚本式编程。</p></li><li><p>交互式编程就是直接输入语法，就能执行。</p></li><li><p>脚本式编程需要编写脚本文件，然后再执行。</p></li></ul><p>一般采用脚本式编程。（例如：编写一个hello.lua的文件，输入文件内容，并执行lua hello.lua即可）</p><h4 id="4-1注释"><a href="#4-1注释" class="headerlink" title="4.1注释"></a>4.1注释</h4><p>单行注释：两个减号是单行注释:</p><pre><code>--</code></pre><p>多行注释：</p><pre><code>--[[ 多行注释 多行注释 --]]</code></pre><h4 id="4-2关键字"><a href="#4-2关键字" class="headerlink" title="4.2关键字"></a>4.2关键字</h4><p>关键字就好比java中的 break if else等等一样的效果。lua的关键字如下：</p><table><thead><tr><th align="left"></th><th></th><th></th><th align="center"></th></tr></thead><tbody><tr><td align="left">and</td><td>break</td><td>do</td><td align="center">else</td></tr><tr><td align="left">elseif</td><td>end</td><td>false</td><td align="center">for</td></tr><tr><td align="left">function</td><td>if</td><td>in</td><td align="center">local</td></tr><tr><td align="left">nil        声明当前变量无效</td><td>not</td><td>or</td><td align="center">repeat</td></tr><tr><td align="left">return</td><td>then</td><td>true</td><td align="center">until</td></tr><tr><td align="left">while</td><td></td><td></td><td align="center"></td></tr></tbody></table><h4 id="4-3-定义变量"><a href="#4-3-定义变量" class="headerlink" title="4.3 定义变量"></a>4.3 定义变量</h4><p>全局变量，默认的情况下，定义一个变量都是全局变量，</p><p>如果要用局部变量 需要声明为local.例如：</p><pre><code>-- 全局变量赋值a=1-- 局部变量赋值local b=2 </code></pre><p>如果变量没有初始化：则 它的值为nil 这和java中的null不同。</p><h4 id="4-4-Lua中的数据类型"><a href="#4-4-Lua中的数据类型" class="headerlink" title="4.4 Lua中的数据类型"></a>4.4 Lua中的数据类型</h4><p>Lua 是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。</p><p>Lua 中有 8 个基本类型分别为：nil、boolean、number、string、userdata、function、thread 和 table。</p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>nil</td><td>这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td></tr><tr><td>boolean</td><td>包含两个值：false和true。</td></tr><tr><td>number</td><td>表示双精度类型的实浮点数</td></tr><tr><td>string</td><td>字符串由一对双引号或单引号来表示</td></tr><tr><td>function</td><td>由 C 或 Lua 编写的函数</td></tr><tr><td>userdata</td><td>表示任意存储在变量中的C数据结构</td></tr><tr><td>thread</td><td>表示执行的独立线路，用于执行协同程序</td></tr><tr><td>table</td><td>Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</td></tr></tbody></table><h4 id="4-5-流程控制"><a href="#4-5-流程控制" class="headerlink" title="4.5 流程控制"></a>4.5 流程控制</h4><p>如下：类似于if else</p><pre><code>--[ 0 为 true ]if(0) then    print("0 为 true")else    print("0 不为true")end</code></pre><h4 id="4-6-函数"><a href="#4-6-函数" class="headerlink" title="4.6 函数"></a>4.6 函数</h4><p>lua中也可以定义函数，类似于java中的方法。例如：</p><pre><code>--[[ 函数返回两个值的最大值 --]]function max(num1, num2)   if (num1 &gt; num2) then      result = num1;   else      result = num2;   end   return result; end-- 调用函数print("两值比较最大值为 ",max(10,4))print("两值比较最大值为 ",max(5,6))</code></pre><p>执行之后的结果：</p><pre><code>两值比较最大值为     10两值比较最大值为     6</code></pre><h4 id="4-7require-函数"><a href="#4-7require-函数" class="headerlink" title="4.7require 函数"></a>4.7require 函数</h4><p>require 用于 引入其他的模块，类似于java中的类要引用别的类的效果。</p><p>用法：</p><pre><code>require "&lt;模块名&gt;"</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对Navicat Premium连接Oracle时报错，提示信息oracle library is not loaded的问题的解决方案</title>
      <link href="/2020/10/22/dui-navicat-premium-lian-jie-oracle-shi-bao-cuo-ti-shi-xin-xi-oracle-library-is-not-loaded-de-wen-ti-de-jie-jue-fang-an/"/>
      <url>/2020/10/22/dui-navicat-premium-lian-jie-oracle-shi-bao-cuo-ti-shi-xin-xi-oracle-library-is-not-loaded-de-wen-ti-de-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<p>对Navicat Premium连接Oracle时报错，提示信息oracle library is not loaded的问题的解决方案</p><p>解决方案：配置Navicat Premium的环境，具体方法如下：</p><p>1.打开<a href="http://www.oracle.com/technetwork/database/database-technologies/instant-client/downloads/index.html">http://www.oracle.com/technetwork/database/database-technologies/instant-client/downloads/index.html</a></p><p>2.选择跟自己操作系统匹配的“instant Client”。</p><img src="/2020/10/22/dui-navicat-premium-lian-jie-oracle-shi-bao-cuo-ti-shi-xin-xi-oracle-library-is-not-loaded-de-wen-ti-de-jie-jue-fang-an/1.png" style="zoom: 50%;"><p>3.下载此文件</p><img src="/2020/10/22/dui-navicat-premium-lian-jie-oracle-shi-bao-cuo-ti-shi-xin-xi-oracle-library-is-not-loaded-de-wen-ti-de-jie-jue-fang-an/2.jpg" style="zoom: 33%;"><p>4.打开对Navicat-Premium进行环境配置</p><img src="/2020/10/22/dui-navicat-premium-lian-jie-oracle-shi-bao-cuo-ti-shi-xin-xi-oracle-library-is-not-loaded-de-wen-ti-de-jie-jue-fang-an/3.jpg" style="zoom: 33%;"><p>5.配置环境</p><img src="/2020/10/22/dui-navicat-premium-lian-jie-oracle-shi-bao-cuo-ti-shi-xin-xi-oracle-library-is-not-loaded-de-wen-ti-de-jie-jue-fang-an/4.jpg" style="zoom:33%;"><p>6.重启对Navicat-Premium，即可解决问题</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tapestry的开发详情</title>
      <link href="/2020/10/14/tapestry-de-kai-fa-xiang-qing/"/>
      <url>/2020/10/14/tapestry-de-kai-fa-xiang-qing/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Tapestry流程分析和组件介绍"><a href="#一、Tapestry流程分析和组件介绍" class="headerlink" title="一、Tapestry流程分析和组件介绍"></a>一、Tapestry流程分析和组件介绍</h2><p>​    Tapestry是一个全面web application框架，是使用JAVA写的。 Tapestry不是一个application server，Tapestry是一个使用在application server中的框架。 Tapestry不是一个application，Tapestry是一个用来创建web application的框架。 Tapestry不是JSP的一种使用方式，Tapestry和JSP只能够选择一种。 Tapestry不是一个脚本环境，Tapestry使用一种组件对象模式（component object model），这 并不是一种简单的脚本，而是用于生成高动态性高互交性的web页面。</p><p>Tapestry 的灵魂：基于组件</p><p>1.使用Tapestry的好处</p><ul><li>能够保证对 HTML 最少限度的干扰，也就是说，美工和表现层程序员有了非常明确的分工。 Tapestry 对 HTML 页面的介入可以仅仅是增加一个 jwcid 属性</li><li>基于组件，使得我们的表现层变成由一个个“积木”堆积而成。 Page 规范就是这些积木之 间的纽带。而 java 文件担当了处理逻辑的角色。</li><li>表现层逻辑全部放在了 java 文件里面，操作方便</li><li>提高工作效率</li></ul><p>2.Tapestry工作原理</p><pre><code> Tapestry应用程序由几个页面组成，这些页面都是由独立的，可重复使用，可配置的组件组 成。</code></pre><p>​     页面（Page）：应用程序由一堆命名唯一的页面组成，每个页面有一个模板和若干组件；</p><p>​     模板（Template）：一个用于页面（或一个组件）的HTML模板。Tapestry中，一个模板包括基本的HTML markup，以及一些用于标记组件的特殊属性的标签。</p><p>​     组件（Component）：用于Tapestry页面的可重复使用的对象。当一个页面表现时，或者页面中的一个链接被触发时，组件产生相应的HTML代码。多个组件也可以用来构成一个新的组件。</p><p>​     参数（Parameter）：组件拥有一些参数，用于组件属性与页面属性之间的连接。组件通 常读取自己的参数，但是一些组件（与HTML forms相关）能够更新自己的参数，并且 更新与参数绑定的页面属性。</p><p>3.页面结构</p><p>​    在Tapestry应用程序中，一个页面（page）由一个HTML模块，一个页面规范（page specification），和一个JAVA页面类（page class）构成。</p><p>​    每个Tapestry页面有一个特殊的唯一的名称。页面名称被用来定位页面规范和HTML模 板。页面规范的一部分用来实例化JAVA类，这部分称为页面类（page class），包括指定应 用程序中的一些特殊属性和方法。</p><p>​     表现（rendering）页面的第一步是实例化页面。Tapestry框架读取页面规范和HTML模板 并生成页面实例。一个Tapestry页面不是一个单一的对象。页面对象是树对象的根对象，这 些对象包括页面模板中的组件，HTML模板中的内容，以及一些用来连接分散区域的对象。</p><p>4.最简单的页面：</p><p> 1）一个HTML模板；</p><p> 2）一个页面规范； 该规范使用XML，必须声明：  </p><p> 3）一个页面类； 该类必须继承BasePage类。</p><p>​         public abstract class HomePage extends BasePage { } </p><p>​         只要HTML模板中使用Tapestry，就必须声明页面规范和页面类，即便页面规范和页面 类都没有任何属性或方法，变量。</p><p>5.关于属性标签： </p><p>a) jwcid属性：（Java Web Component ID）在模板中用来指定组件。</p><p>b) 标签：HTML标签是一个用来包容text和elements的容器，其本身并不能 显示任何内容，仅仅是作为一个stylesheet协助对页面显示的控制。 </p><p>c) @记号：用来标明一个隐式组件。</p><p>属性指定机制（specified properties）</p><p>​    属性指定就是由Tapestry自动生成典型的JavaBean属性。在代码中，定义抽象方法用来读取和更新属性，只需定义即将使用的方法。Tapestry自己会生成一个子类来实现你的方法。你甚至 不用声明变量，只需要在页面规范中指明类型即可。</p><pre><code>&lt;page-specification class="com.cdmcs.tapestry.page.MessageBoard"&gt; &lt;property-specification name="guestBookService"type="com.cdmcs.oa.service.GuestBookService"&gt; global.springContext.getBean("guestBookService") &lt;/property-specification&gt; &lt;property-specification name="item" type="com.cdmcs.bo.Persistable"/&gt;&lt;/page-specification&gt;</code></pre><p>6.组件</p><p>A）Foreach组件：Foreach是一个循环组件，</p><p>B）Insert组件：就是实现 out.print()的功能。</p><p>C）Image 组件：用于插入<img>标签，通过 image 参数生成标签 src 的 属性。标签 alt 用来显示图片名称。</p><p>​      Conditional 组件:该组件只有一个参数 condition，如果 condition 参数的值为 true，就运行 Conditional 组件的 标签范围内的 HTML 模板，相反则不运行。</p><p>D）GenericLink 组件:这个组件有个 href 参数，其作用很明显，就是提供一个链接地址.</p><p>E）ExternalLink 组件:</p><p>F）Form 组件：</p><p>7.面向元素的组件：</p><p>Checkbox、form、ImageSubmit、Option、Radio、RadioGroup、Select、TextArea、TextField</p><p>8.面向任务的组件</p><p>PropertySelection  生成一个下拉菜单</p><p>Hidden 当表单提交时，记录property值</p><p>ListEdit  类似于Foreach，不过在form中，工作得更好</p><p>Upload 允许文件从客户端上传</p><p>Datepicker  使用javascript做的，弹出窗口，允许用户输入日期</p><h2 id="二、Tapestry运行机制"><a href="#二、Tapestry运行机制" class="headerlink" title="二、Tapestry运行机制"></a>二、Tapestry运行机制</h2><p>1， 处理请求 </p><p> 1） 解析和缓存：页面规范、页面模板，组件规范和组件模板。</p><p> 2） Pooling instances of pages </p><p> 3） 管理服务器端状态，包括页面持久化 properties。</p><p> 4） 解释送进来的请求，分派给当前对象和方法。</p><p> Request cycle  对应处理单一请求，临时缓存页面实例</p><p> Rage recorder  为单一页面管理持久化页面 properties，在页面 properties 和 HttpSession 之间传递数据</p><p> Page source   被request cycle 用来管理对象池获取对象实例</p><p> Page loader   根据需要，创建和设置新页面对象</p><p> Application servlet  为 Servlet API 和 Tapestry 之间提供服务桥</p><p> Engine  担当整个请求处理，服务器端状态管理和 Tapestry 子系统访问 的中心角色</p><p> Engine service  为特定的 Tapestry 运作建立并解释 URLs </p><p> Request context  创建一个 Servlet API 对象（HttpServletRequest, HttpSession,等）的 facade </p><p>​        应用程序中有多种 servlet，每一种 servlet 表现了应用程序中可能发生的不同操作。每一个 servlet 都需要你写新的代码，并对代码进行测试和调试。 编写 servlet 代码比编写其它大多数 java 应用程序困难的原因之一，就是 servlet 应用于 不同的环境。Servlet 容器会为每一个 servlet 创建一个实例。也就是说，可能单一的 servlet 会处理十几个并发的请求，而每一个请求又是独立线程。任何当前客户端的信息都将被储 存在实例变量里面，而其它的线程肯定会马上重写那些实例变量。所有这些都发生得非常 频繁，而一旦程序员违反基本规则，就很容易产生 BUG。 框架提供了 ApplicationServlet 类，并且不需要继承其它类。在 Tapestsry 中，应用程序 servlet 仅仅是 stataless，HTTP 协议的多线程和 Servlet API，正常的 stateful 和 java 单一线程, 及 javaBean 单一线程之间的门户。</p><p>三、Tapestry相关配置</p><ul><li>&lt; servlet-class&gt;任何时候都应该是ApplicationServlet。几乎没有太多的必要创建子类；Tapestry有非常多的钩子用于扩展应用程序。</li><li>定义一个<load-on-startup>通常是非常有用的，这使servlet容器在启动时就会初始化应用程序的servlet，因此此时便会读取Tapestry应用程序的说明文件。很多常见的部署错误立刻便会报告，而不用等到应用第一次被请求时。</load-on-startup></li><li>这个 servlet 被映射在 context 内的 /app 路径下。context自身有一个路径，由应用服务器和WAR文件的名称确定。web浏览器可以通过 http://<em>host</em>/<em>war-name</em>/app 访问到该应用。</li><li>使用 /app 作为URL只是创建Tapestry应用程序的一个惯例，而不是限定。如果你需要使用其它的URL，你还得记得覆盖 org.apache.tapestry.servlet-path 属性。</li><li>当请求路径为web应用的context时，RedirectFilter 过滤器会为用户发出一个重定位请求，将请求直接转到应用程序的servlet。这样，应用程序的“共有” URL 可以为 <a href="http://myserver/mycontext/%EF%BC%8C%E8%80%8C%E5%AE%9E%E9%99%85%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%AF">http://myserver/mycontext/，而实际访问的地址是</a> <a href="http://myserver/mycontext/app%E3%80%82">http://myserver/mycontext/app。</a></li><li>在初始化时，Tapestry 的 servlet 会查找应用说明（specification）；该说明定义了应用程序的详细信息，包括应用中使用的页面和组件，以及所有使用的库文件。Tapestry 提供了一个非常灵活的说明文件存储策略；简单的 Tapestry 应用可以不需要程序说明文件。</li></ul><p>Tapestry 现在可使用的所有可配置的属性：</p><p>​        org.apache.tapestry.accepted-locales    控制哪些 locals 被应用程序支持</p><p>​        org.apache.tapestry.bean-class-packages      一个用逗号隔开的列表，用来将受管理的 beans （使用 <bean> 元素定义的）的类名转化为一个合法的完整的类名。这个属性可以定义在所包含的库(liberary)或应用的说明(specification)中。</bean></p><p>​        org.apache.tapestry.component-class-packages        一个使用逗号隔开的包含包名(package names)的列表。在搜索组件类文件是会使用。必须使用 <meta> 标签在应用说明或包说明中定义。</p><p>​        org.apache.tapestry.default-binding-prefix        在没有明确定义绑定规则时默认使用的绑定规则。通常定义在页面或组件内，或者定义在应用说明或包说明中(作用于所有的页面和组件)。如果定义，默认为”ognl”。</p><p>​        org.apache.tapestry.default-cookie-max-age        Tapestry生成cookies的最大默认有效期(秒级)，包括用于跟踪用户 locale 的 cookie。如果值为 -1 说明 cookie是会话 cookie，仅在用户退出浏览器前有效。默认值为一个星期。</p><p>​        org.apache.tapestry.disable-caching        如果定义为”true”，框架会在每个请求周期结束时抛弃所有缓存的数据（定义，模版，缓存对象等）这会极大的降低请求响应的速度，但是在开发时非常有用。也就是说，在改变模板和说明之后立即就会生效。它对发现与管理页面持久化状态的问题也有帮助。这个配置不应该在产品中出现；性能会受到极大的影响。不象其它的配置属性，这个必须作为 JVM 的系统属性设置。</p><p>​        </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Tapestry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svn的使用</title>
      <link href="/2020/10/12/svn-de-shi-yong/"/>
      <url>/2020/10/12/svn-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h5 id="一、svn的生命周期"><a href="#一、svn的生命周期" class="headerlink" title="一、svn的生命周期"></a>一、svn的生命周期</h5><p>1.创建版本</p><p>​    版本库相当于一个集中的空间，用于存放开发者所有的工作成果。版本库不仅能存放文件，还包括了每次修改的历史，即每个文件的变动历史。Create 操作是用来创建一个新的版本库。大多数情况下这个操作只会执行一次。当你创建一个新的版本库的时候，你的版本控制系统会让你提供一些信息来标识版本库，例如创建的位置和版本库的名字。</p><p>2.检出</p><p>​    Checkout 操作是用来从版本库创建一个工作副本。工作副本是开发者私人的工作空间，可以进行内容的修改，然后提交到版本库中。</p><p>3.更新</p><p>​    update 操作是用来更新版本库的。这个操作将工作副本与版本库进行同步。由于版本库是由整个团队共用的，当其他人提交了他们的改动之后，你的工作副本就会过期。</p><p>​    假设 Tom 和 Jerry 是一个项目的两个开发者。他们同时从版本库中检出了最新的版本并开始工作。此时，工作副本是与版本库完全同步的。然后，Jerry 很高效的完成了他的工作并提交了更改到版本库中。</p><p>​    此时 Tom 的工作副本就过期了。更新操作将会从版本库中拉取 Jerry 的最新改动并将 Tom 的工作副本进行更新。</p><p>4.执行变更</p><p>​    当检出之后，你就可以做很多操作来执行变更。编辑是最常用的操作。你可以编辑已存在的文件，例如进行文件的添加/删除操作。</p><p>你可以添加文件/目录。但是这些添加的文件目录不会立刻成为版本库的一部分，而是被添加进待变更列表中，直到执行了 commit 操作后才会成为版本库的一部分。</p><p>​    同样地你可以删除文件/目录。删除操作立刻将文件从工作副本中删除掉，但该文件的实际删除只是被添加到了待变更列表中，直到执行了 commit 操作后才会真正删除。</p><p>​    Rename 操作可以更改文件/目录的名字。”移动”操作用来将文件/目录从一处移动到版本库中的另一处。</p><p>5.复查变化</p><p>​    当你检出工作副本或者更新工作副本后，你的工作副本就跟版本库完全同步了。但是当你对工作副本进行一些修改之后，你的工作副本会比版本库要新。在 commit 操作之前复查下你的修改是一个很好的习惯。</p><p>​    Status 操作列出了工作副本中所进行的变动。正如我们之前提到的，你对工作副本的任何改动都会成为待变更列表的一部分。Status 操作就是用来查看这个待变更列表。</p><p>​    Status 操作只是提供了一个变动列表，但并不提供变动的详细信息。你可以用 diff 操作来查看这些变动的详细信息。</p><p>6.修复错误</p><p>​    假设你对工作副本做了许多修改，但是现在你不想要这些修改了，这时候 revert 操作将会帮助你。</p><p>​    Revert 操作重置了对工作副本的修改。它可以重置一个或多个文件/目录。当然它也可以重置整个工作副本。在这种情况下，revert 操作将会销毁待变更列表并将工作副本恢复到原始状态。</p><p>7.解决冲突</p><p>​    合并的时候可能会发生冲突。Merge 操作会自动处理可以安全合并的东西。其它的会被当做冲突。例如，”hello.c” 文件在一个分支上被修改，在另一个分支上被删除了。这种情况就需要人为处理。Resolve 操作就是用来帮助用户找出冲突并告诉版本库如何处理这些冲突。</p><p>8.提交更改</p><p>​    Commit 操作是用来将更改从工作副本到版本库。这个操作会修改版本库的内容，其它开发者可以通过更新他们的工作副本来查看这些修改。</p><p>​    在提交之前，你必须将文件/目录添加到待变更列表中。列表中记录了将会被提交的改动。当提交的时候，我们通常会提供一个注释来说明为什么会进行这些改动。这个注释也会成为版本库历史记录的一部分。Commit 是一个原子操作，也就是说要么完全提交成功，要么失败回滚。用户不会看到成功提交一半的情况。</p><h5 id="二、svn启动模式"><a href="#二、svn启动模式" class="headerlink" title="二、svn启动模式"></a>二、svn启动模式</h5><p>首先,在服务端进行SVN版本库的相关配置</p><p>手动新建版本库目录</p><pre class=" language-shell"><code class="language-shell">mkdir /opt/svn</code></pre><p>利用svn命令创建版本库</p><pre class=" language-shell"><code class="language-shell">svnadmin create /opt/svn/runoob</code></pre><p>使用命令svnserve启动服务</p><pre><code>svnserve -d -r 目录 --listen-port 端口号</code></pre><ul><li><p><strong>-r:</strong> 配置方式决定了版本库访问方式。</p></li><li><p><strong>–listen-port:</strong> 指定SVN监听端口，不加此参数，SVN默认监听3690</p></li><li><p>由于-r 配置方式的不一样，SVN启动就可以有两种不同的访问方式</p></li><li><p>方式一：-r直接指定到版本库(称之为单库svnserve方式)</p></li><li><pre><code>svnserve -d -r /opt/svn/runoob</code></pre></li><li><p>在这种情况下，一个svnserve只能为一个版本库工作。</p></li><li><p>authz配置文件中对版本库权限的配置应这样写：</p></li><li><pre><code>[groups]admin=user1dev=user2[/]@admin=rwuser2=r</code></pre></li><li><p>使用类似这样的URL：svn://192.168.0.1/　即可访问runoob版本库</p></li><li><p>方式二：指定到版本库的上级目录(称之为多库svnserve方式)</p></li><li><pre><code>svnserve -d -r /opt/svn</code></pre></li><li><p>这种情况，一个svnserve可以为多个版本库工作</p></li><li><p>authz配置文件中对版本库权限的配置应这样写：</p></li><li><pre><code>[groups]admin=user1dev=user2[runoob:/]@admin=rwuser2=r[runoob01:/]@admin=rwuser2=r</code></pre></li><li><p>如果此时你还用[/]，则表示所有库的根目录，同理，[/src]表示所有库的根目录下的src目录。</p></li><li><p>使用类似这样的URL：svn://192.168.0.1/runoob　即可访问runoob版本库</p></li></ul><h5 id="三、svn创建版本库"><a href="#三、svn创建版本库" class="headerlink" title="三、svn创建版本库"></a>三、svn创建版本库</h5><p>使用svn命令创建资源库</p><pre><code>[runoob@centos6 ~]# svnadmin create /opt/svn/runoob01[runoob@centos6 ~]# ll /opt/svn/runoob01/total 24drwxr-xr-x 2 root root 4096 2016/08/23 16:31:06 confdrwxr-sr-x 6 root root 4096 2016/08/23 16:31:06 db-r--r--r-- 1 root root    2 2016/08/23 16:31:06 formatdrwxr-xr-x 2 root root 4096 2016/08/23 16:31:06 hooksdrwxr-xr-x 2 root root 4096 2016/08/23 16:31:06 locks-rw-r--r-- 1 root root  229 2016/08/23 16:31:06 README.txt</code></pre><p>进入/opt/svn/runoob01/conf目录 修改默认配置文件配置，包括svnserve.conf、passwd、authz 配置相关用户和权限。</p><p>1、svn服务配置文件svnserve.conf</p><p>svn服务配置文件为版本库目录中的文件conf/svnserve.conf。该文件仅由一个[general]配置段组成。</p><pre><code>[general]anon-access = noneauth-access = writepassword-db = /home/svn/passwdauthz-db = /home/svn/authzrealm = tiku </code></pre><ul><li><strong>anon-access:</strong> 控制非鉴权用户访问版本库的权限，取值范围为”write”、”read”和”none”。 即”write”为可读可写，”read”为只读，”none”表示无访问权限。 默认值：read</li><li><strong>auth-access:</strong> 控制鉴权用户访问版本库的权限。取值范围为”write”、”read”和”none”。 即”write”为可读可写，”read”为只读，”none”表示无访问权限。 默认值：write</li><li><strong>authz-db:</strong> 指定权限配置文件名，通过该文件可以实现以路径为基础的访问控制。 除非指定绝对路径，否则文件位置为相对conf目录的相对路径。 默认值：authz</li><li><strong>realm:</strong> 指定版本库的认证域，即在登录时提示的认证域名称。若两个版本库的 认证域相同，建议使用相同的用户名口令数据文件。 默认值：一个UUID(Universal Unique IDentifier，全局唯一标示)。</li></ul><p>2、用户名口令文件passwd</p><p>用户名口令文件由svnserve.conf的配置项password-db指定，默认为conf目录中的passwd。该文件仅由一个[users]配置段组成。</p><p>[users]配置段的配置行格式如下：</p><pre><code>&lt;用户名&gt; = &lt;口令&gt;[users]admin = adminthinker = 123456</code></pre><p>3、权限配置文件</p><p>权限配置文件由svnserve.conf的配置项authz-db指定，默认为conf目录中的authz。该配置文件由一个[groups]配置段和若干个版本库路径权限段组成。</p><p>[groups]配置段中配置行格式如下：</p><pre><code>&lt;用户组&gt; = &lt;用户列表&gt;</code></pre><p>版本库路径权限段的段名格式如下：</p><pre><code>[&lt;版本库名&gt;:&lt;路径&gt;] [groups]g_admin = admin,thinker[admintools:/]@g_admin = rw* =[test:/home/thinker]thinker = rw* = r</code></pre><h5 id="四、svn检出操作"><a href="#四、svn检出操作" class="headerlink" title="四、svn检出操作"></a>四、svn检出操作</h5><p>代码拉取</p><h5 id="五、解决冲突"><a href="#五、解决冲突" class="headerlink" title="五、解决冲突"></a>五、解决冲突</h5><p>假设 A、B 两个用户都在版本号为 100 的时候，更新了 kingtuns.txt 这个文件，A 用户在修改完成之后提交 kingtuns.txt 到服务器， 这个时候提交成功，这个时候 kingtuns.txt 文件的版本号已经变成 101 了。同时B用户在版本号为 100 的 kingtuns.txt 文件上作修改， 修改完成之后提交到服务器时，由于不是在当前最新的 101 版本上作的修改，所以导致提交失败。</p><p>我们已在本地检出 runoob01 库，下面我们将实现版本冲突的解决方法。</p><p>我们发现 HelloWorld.html 文件存在错误，需要修改文件并提交到版本库中。</p><p>我们将 HelloWorld.html 的内容修改为 “HelloWorld! <a href="http://www.runoob.com/&quot;%E3%80%82">http://www.runoob.com/"。</a></p><pre><code>root@runoob:~/svn/runoob01/trunk# cat HelloWorld.html HelloWorld! http://www.runoob.com/</code></pre><p>用下面的命令查看更改：</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn diff Index: HelloWorld.html===================================================================--- HelloWorld.html     (revision 5)+++ HelloWorld.html     (working copy)@@ -1,2 +1 @@-HelloWorld! http://www.runoob.com/+HelloWorld! http://www.runoob.com/!</code></pre><p>尝试使用下面的命令来提交他的更改：</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn commit -m "change HelloWorld.html first"Sending        HelloWorld.htmlTransmitting file data .svn: E160028: Commit failed (details follow):svn: E160028: File '/trunk/HelloWorld.html' is out of date</code></pre><p>这时我发现提交失败了。</p><p>因为此时，HelloWorld.html 已经被 user02 修改并提交到了仓库。Subversion 不会允许 user01(本例使用的 svn 账号)提交更改，因为 user02 已经修改了仓库，所以我们的工作副本已经失效。</p><p>为了避免两人的代码被互相覆盖，Subversion 不允许我们进行这样的操作。所以我们在提交更改之前必须先更新工作副本。所以使用 update 命令，如下：</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn updateUpdating '.':C    HelloWorld.htmlUpdated to revision 6.Conflict discovered in file 'HelloWorld.html'.Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,        (mc) my side of conflict, (tc) their side of conflict,        (s) show all options: mcResolved conflicted state of 'HelloWorld.html'Summary of conflicts:  Text conflicts: 0 remaining (and 1 already resolved)</code></pre><p>这边输入”mc”,以本地的文件为主。你也可以使用其选项对冲突的文件进行不同的操作。</p><p>默认是更新到最新的版本，我们也可以指定更新到哪个版本</p><pre><code>svn update -r6</code></pre><p>此时工作副本是和仓库已经同步，可以安全地提交更改了</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn commit -m "change HelloWorld.html second"Sending        HelloWorld.htmlTransmitting file data .Committed revision 7.</code></pre><h5 id="六、svn提交操作"><a href="#六、svn提交操作" class="headerlink" title="六、svn提交操作"></a>六、svn提交操作</h5><p>我们在库本版中需要增加一个readme的说明文件。</p><pre><code>root@runoob:~/svn/runoob01/trunk# cat readme this is SVN tutorial.</code></pre><p>查看工作副本中的状态。</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn status?       readme</code></pre><p>此时 readme的状态为？，说明它还未加到版本控制中。</p><p>将文件readme加到版本控制，等待提交到版本库。</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn add readme A         readme</code></pre><p>查看工作副本中的状态</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn status     A       readme</code></pre><p>此时 readme的状态为A,它意味着这个文件已经被成功地添加到了版本控制中。</p><p>为了把 readme 存储到版本库中，使用 commit -m 加上注释信息来提交。</p><p>如果你忽略了 -m 选项， SVN会打开一个可以输入多行的文本编辑器来让你输入提交信息。</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn commit -m "SVN readme."Adding         readmeTransmitting file data .Committed revision 8.svn commit -m "SVN readme."</code></pre><h5 id="七、版本回退"><a href="#七、版本回退" class="headerlink" title="七、版本回退"></a>七、版本回退</h5><p>​    当我们想放弃对文件的修改，可以使用 <strong>SVN revert</strong> 命令。</p><p>svn revert 操作将撤销任何文件或目录里的局部更改。</p><p>我们对文件 readme 进行修改,查看文件状态。</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn statusM       readme</code></pre><p>这时我们发现修改错误，要撤销修改，通过 svn revert 文件 readme 回归到未修改状态。</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn revert readme Reverted 'readme'</code></pre><p>再查看状态。</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn status root@runoob:~/svn/runoob01/trunk# </code></pre><p>进行 revert 操作之后，readme 文件恢复了原始的状态。 revert 操作不单单可以使单个文件恢复原状， 而且可以使整个目录恢复原状。恢复目录用 -R 命令，如下。</p><pre><code>svn revert -R trunk</code></pre><p>但是，假如我们想恢复一个已经提交的版本怎么办。</p><p>为了消除一个旧版本，我们必须撤销旧版本里的所有更改然后提交一个新版本。这种操作叫做 reverse merge。</p><p>首先，找到仓库的当前版本，现在是版本 22，我们要撤销回之前的版本，比如版本 21。</p><pre><code>svn merge -r 22:21 readme </code></pre><h5 id="八、svn查看历史信息"><a href="#八、svn查看历史信息" class="headerlink" title="八、svn查看历史信息"></a>八、svn查看历史信息</h5><p>1.svn log</p><p>可以显示所有的信息，如果只希望查看特定的某两个版本之间的信息，可以使用：</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn log -r 6:8</code></pre><p>如果只想查看某一个文件的版本修改信息，可以使用 <strong>svn log</strong> 文件路径。</p><pre><code>root@runoob:~/svn/runoob01# svn log trunk/HelloWorld.html </code></pre><p>如果希望得到目录的信息要加 <strong>-v</strong>。</p><p>如果希望显示限定N条记录的目录信息，使用 <strong>svn log -l N -v</strong>。</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn log -l 5 -v </code></pre><p>2.svn diff</p><p>用来检查历史修改的详情。</p><ul><li><p>检查本地修改</p></li><li><p>比较工作拷贝与版本库</p></li><li><p>比较版本库与版本库</p><p>（1）、如果用 svn diff，不带任何参数，它将会比较你的工作文件与缓存在 .svn 的”原始”拷贝。</p><pre class=" language-shell"><code class="language-shell">root@runoob:~/svn/runoob01/trunk# svn diff</code></pre><p>（2）、比较工作拷贝和版本库</p><p>比较你的工作拷贝和版本库中版本号为 3 的文件 rule.txt。</p><pre><code>svn diff -r 3 rule.txt</code></pre><p>（3）、比较版本库与版本库</p><p>通过 -r(revision) 传递两个通过冒号分开的版本号，这两个版本会进行比较。</p><p>比较 svn 工作版本中版本号2和3的这个文件的变化。</p><pre><code>svn diff -r 2:3 rule.txt</code></pre></li></ul><p>3.svn cat</p><p>如果只是希望检查一个过去版本，不希望查看他们的区别，可使用svn cat</p><pre><code>svn cat -r 版本号 rule.txt</code></pre><p>这个命令会显示在该版本号下的该文件内容</p><hr><p>4.svn list</p><p>s<strong>vn list</strong> 可以在不下载文件到本地目录的情况下来察看目录中的文件：</p><pre><code>$ svn list http://192.168.0.1/runoob01READMEbranches/clients/tags/</code></pre><h5 id="九、svn分支"><a href="#九、svn分支" class="headerlink" title="九、svn分支"></a>九、svn分支</h5><p>Branch 选项会给开发者创建出另外一条线路。当有人希望开发进程分开成两条不同的线路时，这个选项会非常有用。</p><p>比如项目 demo 下有两个小组，svn 下有一个 trunk 版。</p><p>由于客户需求突然变化，导致项目需要做较大改动，此时项目组决定由小组 1 继续完成原来正进行到一半的工作（某个模块），小组 2 进行新需求的开发。</p><p>那么此时，我们就可以为小组2建立一个分支，分支其实就是 trunk 版（主干线）的一个copy版，不过分支也是具有版本控制功能的，而且是和主干线相互独立的，当然，到最后我们可以通过（合并）功能，将分支合并到 trunk 上来，从而最后合并为一个项目。</p><p>我们在本地副本中创建一个 <strong>my_branch</strong> 分支。</p><pre><code>root@runoob:~/svn/runoob01# lsbranches  tags  trunkroot@runoob:~/svn/runoob01# svn copy trunk/ branches/my_branchA         branches/my_branchroot@runoob:~/svn/runoob01# </code></pre><p>查看状态：</p><pre><code>root@runoob:~/svn/runoob01# svn statusA  +    branches/my_branchA  +    branches/my_branch/HelloWorld.htmlA  +    branches/my_branch/readme</code></pre><p>提交新增的分支到版本库。</p><pre><code>root@runoob:~/svn/runoob01# svn commit -m "add my_branch" Adding         branches/my_branchReplacing      branches/my_branch/HelloWorld.htmlAdding         branches/my_branch/readmeCommitted revision 9.</code></pre><p>接着我们就到 my_branch 分支进行开发，切换到分支路径并创建 index.html 文件。</p><pre><code>root@runoob:~/svn/runoob01# cd branches/my_branch/root@runoob:~/svn/runoob01/branches/my_branch# lsHelloWorld.html  index.html  readme</code></pre><p>将 index.html 加入版本控制，并提交到版本库中。</p><pre><code>root@runoob:~/svn/runoob01/branches/my_branch# svn status?       index.htmlroot@runoob:~/svn/runoob01/branches/my_branch# svn add index.html A         index.htmlroot@runoob:~/svn/runoob01/branches/my_branch# svn commit -m "add index.html"Adding         index.htmlTransmitting file data .Committed revision 10.</code></pre><p>切换到 trunk，执行 svn update，然后将 my_branch 分支合并到 trunk 中。</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn merge ../branches/my_branch/--- Merging r10 into '.':A    index.html--- Recording mergeinfo for merge of r10 into '.': G   .</code></pre><p>此时查看目录，可以看到 trunk 中已经多了 my_branch 分支创建的 index.html 文件。</p><pre><code>root@runoob:~/svn/runoob01/trunk# lltotal 16drwxr-xr-x 2 root root 4096 Nov  7 03:52 ./drwxr-xr-x 6 root root 4096 Jul 21 19:19 ../-rw-r--r-- 1 root root   36 Nov  7 02:23 HelloWorld.html-rw-r--r-- 1 root root    0 Nov  7 03:52 index.html-rw-r--r-- 1 root root   22 Nov  7 03:06 readme</code></pre><p>将合并好的 trunk 提交到版本库中。</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn commit -m "add index.html"Adding         index.htmlTransmitting file data .Committed revision 11.</code></pre><h5 id="十、svn标签"><a href="#十、svn标签" class="headerlink" title="十、svn标签"></a>十、svn标签</h5><p>版本管理系统支持 tag 选项，通过使用 tag 的概念，我们可以给某一个具体版本的代码一个更加有意义的名字。</p><p>Tags 即标签主要用于项目开发中的里程碑，比如开发到一定阶段可以单独一个版本作为发布等，它往往代表一个可以固定的完整的版本，这跟 VSS 中的 Tag 大致相同。</p><p>我们在本地工作副本创建一个 tag。</p><pre><code>root@runoob:~/svn/runoob01# svn copy trunk/ tags/v1.0A         tags/v1.0</code></pre><p>上面的代码成功完成，新的目录将会被创建在 tags 目录下。</p><pre><code>root@runoob:~/svn/runoob01# ls tags/v1.0root@runoob:~/svn/runoob01# ls tags/v1.0/HelloWorld.html  readme</code></pre><p>查看状态。</p><pre><code>root@runoob:~/svn/runoob01# svn statusA  +    tags/v1.0</code></pre><p>提交tag内容。</p><pre><code>root@runoob:~/svn/runoob01# svn commit -m "tags v1.0" Adding         tags/v1.0Transmitting file data ..Committed revision 14.</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DQL、DDL、DML、DCL的区别</title>
      <link href="/2020/10/12/dql-ddl-dml-dcl-de-qu-bie/"/>
      <url>/2020/10/12/dql-ddl-dml-dcl-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p><strong>SQL结构化查询语言包含6个部分</strong></p><p><strong><em>\</em>1.\</strong>*<em>数据查询语言（DQL: Data Query Language）***</em></p><p>数据检索语句，用于从表中获取数据。通常最常用的为保留字SELECT,并且常与FROM子句、WHERE子句组成查询SQL查询语句。</p><p>语法：</p><p>  SELECT &lt;字段名&gt; FROM &lt;表或视图名&gt; WHERE &lt;查询条件&gt;;</p><p><strong><em>2.数据操纵语言（DML：Data Manipulation Language）</em></strong></p><p>主要用来对数据库的数据进行一些操作，常用的就是INSERT、UPDATE、DELETE。</p><p>语法：</p><p>  INSERT INTO &lt;表名&gt;(列1,列2,…) VALUES (值1,值2,…);</p><p>  UPDATE &lt;表名&gt; SET &lt;列名&gt;=新值 WHERE &lt;列名&gt;=某值;</p><p>  DELETE FROM &lt;表名&gt; WHERE &lt;列名&gt;=某值;</p><p><strong><em>\</em>3.事务处理语言（DPL）**</strong></p><p>事务处理语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION、COMMIT和ROLLBACK。</p><p><strong><em>\</em>4.数据控制语言（DCL）**</strong></p><p>通过GRANT和REVOKE，确定单个用户或用户组对数据库对象的访问权限。</p><p><strong><em>\</em>5.数据定义语言（DDL）**</strong></p><p>常用的有CREATE和DROP，用于在数据库中创建新表或删除表，以及为表加入索引等。</p><p><strong><em>\</em>6.指针控制语言（CCL）**</strong></p><p>它的语句，想DECLARE CURSOR、FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql函数</title>
      <link href="/2020/10/10/sql-han-shu/"/>
      <url>/2020/10/10/sql-han-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="一、sql函数的功能"><a href="#一、sql函数的功能" class="headerlink" title="一、sql函数的功能"></a>一、sql函数的功能</h3><p>​    进行数值计算</p><p>​    修改单个数据项</p><p>​    处理成组行的输出</p><p>​    指定日期和数字的显示格式</p><p>​    转换列数据类型</p><h3 id="二、sql函数的两种类型"><a href="#二、sql函数的两种类型" class="headerlink" title="二、sql函数的两种类型"></a>二、sql函数的两种类型</h3><p>1、单行函数：只处理单个行，并且每行返回一个结果。</p><p>​        字符函数</p><p>​        lower 将字母字符值转换为小写</p><p>​        upper 将字母字符值转换为大写</p><p>​        initcap 将字母字符转换为每个单词首字母大写，其他所有的字母为小写</p><p>​        concap 将第一个字符值与第二个字符值相连；等同与连接运算符</p><p>​        substr 返回字符值中的指定字符 从第m个字符开始，长度为n个字符  m为负数，则从字符值的末尾开始算起</p><p>​        length 返回表达式中的字符数  </p><p>​        instr 返回指定字符串的数字位置</p><p>​        lpad 将字符值右对齐排列，然后左侧填充字符，以使总字符宽度为n</p><p>​        rpad将字符串值左对齐排列，然后右侧填充字符，以使总字符宽度为n</p><p>​        trim 可以从一个字符串中截去或者尾部的字符</p><p>​        replace 搜索字符串的文本格式，如果找到，用指定的替换字符串替换它</p><p>​        数字函数 </p><p>​        日期函数</p><p>​        转换函数</p><p>​        常规函数</p><p>单行函数是处理数据项的。他们接受一个或多个参数。每个行返回一个值（参数可以是用户提供的常数、变量值、列名、表达式）</p><p>​    可以用在select、where和order by 子句中，也可以嵌套</p><p>2、多行函数：这些函数可以处理成组的行，从而每行返回一个结果（分组函数）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tapestry基础知识</title>
      <link href="/2020/10/10/tapestry-ji-chu-zhi-shi/"/>
      <url>/2020/10/10/tapestry-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="1、Tapestry-Web概述"><a href="#1、Tapestry-Web概述" class="headerlink" title="1、Tapestry Web概述"></a>1、Tapestry Web概述</h2><p>​    Tapestry是一种基于java的Web应用程序框架。Tapestry采用了组件的概念。程序员可以应用现有的组件或自定义应用程序相关的组件来构建应用程序。相对与现有的其他Web应用程序框架而言，应用Tapestry会让程序员从烦琐的，不必要的底层代码中解放出来。它使用组件对象模型来创建动态的，交互的web应用。</p><p>​    一个组件就是任意一个带有jwc id属性的html标记。其中jwc的意思是Java Web Component。</p><p>​    Tapestry使得java代码与html完全分离，利用这个框架开发大型应用变得轻而易举。并且开发的应用很容易维护和升级。Tapestry支持本地化，其错误报告也很详细。Tapestry主要利用javabean和xml技术进行开发。</p><p>在Tapestry框架中:</p><p>页面有HTML模板(.html)，页面规范(.page)和页面类(.java)组成;</p><p>组件由HTML模板(.html)[可选]，组件规范(.jwc)和组件类(.java)组成。</p><p>页面的HTML模板和组件的HTML模板都是在原始的HTML静态页面中嵌入少量的jwcid属性标签构成</p><p>页面类和组件类都是抽象或非抽象的Java类，并最终继承于Tapestry的org..apache.tapestry.AbstractComponent类。</p><p>页面对于Tapestry来说，是一种特殊的组件。</p><p>一个使用Tapestry框架的Web应用程序，实际上就是一堆Tapestry组件的集合。</p><h2 id="2、属性路径"><a href="#2、属性路径" class="headerlink" title="2、属性路径"></a>2、属性路径</h2><p>在Tapestry框架中扩展了一个概念“属性路径”</p><p>属性路径：是指一系列的用句号分割的属性名称</p><p>比如visit.userName</p><p>用java代码表示： getVisit().getUserName()</p><h2 id="3、OGNL"><a href="#3、OGNL" class="headerlink" title="3、OGNL"></a>3、OGNL</h2><p>ognl是一种强大的表达式语言</p><p>通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。    </p><h2 id="4、组件："><a href="#4、组件：" class="headerlink" title="4、组件："></a>4、组件：</h2><p>正式/不正式 参数</p><p>Tapestry有两种参数类型：正式参数和不正式参数</p><p>限制性组件:</p><p>$remove$    $content$    </p><h2 id="5、页面类"><a href="#5、页面类" class="headerlink" title="5、页面类"></a>5、页面类</h2><p>页面类是一种特殊的组件</p><p>所有的页面类必须是BasePage</p><p>（org.apache.tapestry.html.BasePage）的子类</p><p>相同点：</p><p>​    有自己的规范文件</p><p>​    可以包含其他组件</p><p>​    有自己的模板</p><p>不同点：</p><p>​    没有参数（页面类处于整个组件层次的最外层）</p><p>页面状态 ：瞬时、动态、持久</p><p>几个特殊的页面类:</p><p>Home:程序开始页面，必须由开发者提供</p><p>Exception:用来显示没有被捕捉的异常信息</p><p>StaleSession:session失效页面</p><p>​                        页面抛出StaleSessionException异常，才显示</p><p>​                        可以覆盖</p><p>StaleLink:连接失效页面</p><p>​                 页面抛出StaleLinkException异常，才显示</p><p>​                 可以覆盖</p><h2 id="6、创建组件"><a href="#6、创建组件" class="headerlink" title="6、创建组件"></a>6、创建组件</h2><p>选择父类</p><p>Tapestry中有两种组件：一种是没有HTML模板的组件——单一型组件，一种是有HTML模板的组件——组合型组件</p><p>单一型组件需要继承AbstractComponent类，并且必须实现renderComponent() 方法。</p><p>组合型组件需要继承BaseComponent（是AbstractComponent的一个子类），不必须再单独的实现renderComponent() 方法</p><p>参数：一般情况下，组件的参数会自动对应Java类中的一个同名属性。</p><h2 id="7、服务"><a href="#7、服务" class="headerlink" title="7、服务"></a>7、服务</h2><p>Tapestry中提供的常见的服务有：page、direct、action、external等等</p><p>大部分服务都有一个关联的组件，比如PageLink、DirectLink、ActionLink、ExternalLink 等等</p><h2 id="8、对象"><a href="#8、对象" class="headerlink" title="8、对象"></a>8、对象</h2><p>visit对象：</p><p>Visit对象是一个Tapestry应用程序的对象容器，用来存储应用程序逻辑和数据，这个对象能被应用程序中所有页面和组件共享。实际上，Visit对象最终作为一个HttpSession的属性被存储。 </p><p>Visit对象在Tapestry框架启动时通过读取应用程序规范文件，将Visit对象的配置信息存入Tapestry框架的引擎对象中。</p><p>Global对象：</p><p>Global对象是一个应用程序空间，用来存储全局性的应用程序逻辑和数据。Global对象最终作为一个ServletContext的属性被储存。<br>可以在规范文件中如此定义</p><pre><code>&lt;property name=“org.apache.tapestry.global-class”&gt;com.linkage.MyGlobal&lt;/property&gt;</code></pre><h2 id="9、配置"><a href="#9、配置" class="headerlink" title="9、配置"></a>9、配置</h2><p>Tapestry的工作原理如下：在web.xml文件中定义一个名为ApplicationServlet的servlet来进行处理所有的http请求，它主要职责是负责引导整个tapestry核心，启动日志功能，读取配置文件，创建工作引擎来指派客户请求。</p><p>配置页面的4个步骤：</p><ol><li>注册名字</li><li>编写html模板</li><li>编写页面规范</li><li>编写页面类</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Tapestry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eureka配置详解</title>
      <link href="/2020/08/10/eureka-pei-zhi-xiang-jie/"/>
      <url>/2020/08/10/eureka-pei-zhi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Euraka配置详解"><a href="#Euraka配置详解" class="headerlink" title="Euraka配置详解"></a>Euraka配置详解</h1><p>Eureka包含四个部分的配置</p><ol><li>instance：当前Eureka Instance实例信息配置</li><li>client：Eureka Client客户端特性配置</li><li>server：Eureka Server注册中心特性配置</li><li>dashboard：Eureka Server注册中心仪表盘配置</li></ol><h2 id="Eureka-Instance实例信息配置"><a href="#Eureka-Instance实例信息配置" class="headerlink" title="Eureka Instance实例信息配置"></a>Eureka Instance实例信息配置</h2><p>Eureka Instance的配置信息全部保存在org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean配置类里，实际上它是com.netflix.appinfo.EurekaInstanceConfig的实现类，替代了netflix的com.netflix.appinfo.CloudInstanceConfig的默认实现。</p><p>Eureka Instance的配置信息全部以eureka.instance.xxx的格式配置。</p><p><strong>配置列表</strong></p><ul><li>appname = unknown</li></ul><p>应用名，首先获取spring.application.name的值，如果取值为空，则取默认unknown。</p><ul><li>appGroupName = null</li></ul><p>应用组名</p><ul><li>instanceEnabledOnit = false</li></ul><p>实例注册到Eureka上是，是否立刻开启通讯。有时候应用在准备好服务之前需要一些预处理。</p><ul><li>nonSecurePort = 80</li></ul><p>非安全的端口</p><ul><li>securePort = 443</li></ul><p>安全端口</p><ul><li>nonSecurePortEnabled = true</li></ul><p>是否开启非安全端口通讯</p><ul><li>securePortEnabled = false</li></ul><p>是否开启安全端口通讯</p><ul><li>leaseRenewalIntervalInSeconds = 30</li></ul><p>实例续约间隔时间</p><ul><li>leaseExpirationDurationInSeconds = 90</li></ul><p>实例超时时间，表示最大leaseExpirationDurationInSeconds秒后没有续约，Server就认为他不可用了，随之就会将其剔除。</p><ul><li>virtualHostName = unknown</li></ul><p>虚拟主机名，首先获取spring.application.name的值，如果取值为空，则取默认unknown。</p><ul><li>instanceId</li></ul><p>注册到eureka上的唯一实例ID，不能与相同appname的其他实例重复。</p><ul><li>secureVirtualHostName = unknown</li></ul><p>安全虚拟主机名，首先获取spring.application.name的值，如果取值为空，则取默认unknown。</p><ul><li>metadataMap = new HashMap();</li></ul><p>实例元数据，可以供其他实例使用。比如spring-boot-admin在监控时，获取实例的上下文和端口。</p><ul><li>dataCenterInfo = new MyDataCenterInfo(DataCenterInfo.Name.MyOwn);</li></ul><p>实例部署的数据中心。如AWS、MyOwn。</p><ul><li>ipAddress=null</li></ul><p>实例的IP地址</p><ul><li>statusPageUrlPath = “/actuator/info”</li></ul><p>实例状态页相对url</p><ul><li>statusPageUrl = null</li></ul><p>实例状态页绝对URL</p><ul><li>homePageUrlPath = “/“</li></ul><p>实例主页相对URL</p><ul><li>homePageUrl = null</li></ul><p>实例主页绝对URL</p><ul><li>healthCheckUrlUrlPath = “/actuator/health”</li></ul><p>实例健康检查相对URL</p><ul><li>healthCheckUrl = null</li></ul><p>实例健康检查绝对URL</p><ul><li>secureHealthCheckUrl = null</li></ul><p>实例安全的健康检查绝对URL</p><ul><li>namespace = “eureka”</li></ul><p>配置属性的命名空间（Spring Cloud中被忽略）</p><ul><li>hostname = null</li></ul><p>主机名,不配置的时候讲根据操作系统的主机名来获取</p><ul><li>preferIpAddress = false</li></ul><p>是否优先使用IP地址作为主机名的标识</p><h2 id="Eureka-Client客户端特性配置"><a href="#Eureka-Client客户端特性配置" class="headerlink" title="Eureka Client客户端特性配置"></a>Eureka Client客户端特性配置</h2><p>Eureka Client客户端特性配置是对作为Eureka客户端的特性配置，包括Eureka注册中心，本身也是一个Eureka Client。</p><p>Eureka Client特性配置全部在org.springframework.cloud.netflix.eureka.EurekaClientConfigBean中，实际上它是com.netflix.discovery.EurekaClientConfig的实现类，替代了netxflix的默认实现。</p><p>Eureka Client客户端特性配置全部以eureka.client.xxx的格式配置。</p><p><strong>配置列表</strong></p><ul><li>enabled=true</li></ul><p>是否启用Eureka client。</p><ul><li>registryFetchIntervalSeconds=30</li></ul><p>定时从Eureka Server拉取服务注册信息的间隔时间</p><ul><li>instanceInfoReplicationIntervalSeconds=30</li></ul><p>定时将实例信息（如果变化了）复制到Eureka Server的间隔时间。（InstanceInfoReplicator线程）</p><ul><li>initialInstanceInfoReplicationIntervalSeconds=40</li></ul><p>首次将实例信息复制到Eureka Server的延迟时间。（InstanceInfoReplicator线程）</p><ul><li>eurekaServiceUrlPollIntervalSeconds=300</li></ul><p>拉取Eureka Server地址的间隔时间（Eureka Server有可能增减）</p><ul><li>proxyPort=null</li></ul><p>Eureka Server的代理端口</p><ul><li>proxyHost=null</li></ul><p>Eureka Server的代理主机名</p><ul><li>proxyUserName=null</li></ul><p>Eureka Server的代理用户名</p><ul><li>proxyPassword=null</li></ul><p>Eureka Server的代理密码</p><ul><li>eurekaServerReadTimeoutSeconds=8</li></ul><p>从Eureka Server读取信息的超时时间</p><ul><li>eurekaServerConnectTimeoutSeconds=5</li></ul><p>连接Eureka Server的超时时间</p><ul><li>backupRegistryImpl=null</li></ul><p>Eureka Client第一次启动时获取服务注册信息的调用的回溯实现。Eureka Client启动时首次会检查有没有BackupRegistry的实现类，如果有实现类，则优先从这个实现类里获取服务注册信息。</p><ul><li>eurekaServerTotalConnections=200</li></ul><p>Eureka client连接Eureka Server的链接总数</p><ul><li>eurekaServerTotalConnectionsPerHost=50</li></ul><p>Eureka client连接单台Eureka Server的链接总数</p><ul><li>eurekaServerURLContext=null</li></ul><p>当Eureka server的列表在DNS中时，Eureka Server的上下文路径。如<a href="http://xxxx/eureka%E3%80%82">http://xxxx/eureka。</a></p><ul><li>eurekaServerPort=null</li></ul><p>当Eureka server的列表在DNS中时，Eureka Server的端口。</p><ul><li>eurekaServerDNSName=null</li></ul><p>当Eureka server的列表在DNS中时，且要通过DNSName获取Eureka Server列表时，DNS名字。</p><ul><li>region=”us-east-1”</li></ul><p>实例所属区域。</p><ul><li>eurekaConnectionIdleTimeoutSeconds = 30</li></ul><p>Eureka Client和Eureka Server之间的Http连接的空闲超时时间。</p><ul><li>heartbeatExecutorThreadPoolSize=2</li></ul><p>心跳（续约）执行器线程池大小。</p><ul><li>heartbeatExecutorExponentialBackOffBound=10</li></ul><p>心跳执行器在续约过程中超时后的再次执行续约的最大延迟倍数。默认最大延迟时间=10 * eureka.instance.leaseRenewalIntervalInSeconds</p><ul><li>cacheRefreshExecutorThreadPoolSize=2</li></ul><p>cacheRefreshExecutord的线程池大小（获取注册信息）</p><ul><li>cacheRefreshExecutorExponentialBackOffBound=10</li></ul><p>cacheRefreshExecutord的再次执行的最大延迟倍数。默认最大延迟时间=10 *eureka.client.registryFetchIntervalSeconds</p><ul><li>serviceUrl= new HashMap();serviceUrl.put(DEFAULT_ZONE, DEFAULT_URL);</li></ul><p>Eureka Server的分区地址。默认添加了一个defualtZone。也就是最常用的配置eureka.client.service-url.defaultZone=xxx</p><ul><li>registerWithEureka=true</li></ul><p>是否注册到Eureka Server。</p><ul><li>preferSameZoneEureka=true</li></ul><p>是否使用相同Zone下的Eureka server。</p><ul><li>logDeltaDiff=false</li></ul><p>是否记录Eureka Server和Eureka Client之间注册信息的差异</p><ul><li>disableDelta=false</li></ul><p>是否开启增量同步注册信息。</p><ul><li>fetchRemoteRegionsRegistry=null</li></ul><p>获取注册服务的远程地区，以逗号隔开。</p><ul><li>availabilityZones=new HashMap()</li></ul><p>可用分区列表。用逗号隔开。</p><ul><li>filterOnlyUpInstances = true</li></ul><p>是否只拉取UP状态的实例。</p><ul><li>fetchRegistry=true</li></ul><p>是否拉取注册信息。</p><ul><li>shouldUnregisterOnShutdown = true</li></ul><p>是否在停止服务的时候向Eureka Server发起Cancel指令。</p><ul><li>shouldEnforceRegistrationAtInit = false</li></ul><p>是否在初始化过程中注册服务。</p><h2 id="Eureka-Server注册中心端配置"><a href="#Eureka-Server注册中心端配置" class="headerlink" title="Eureka Server注册中心端配置"></a>Eureka Server注册中心端配置</h2><p>Eureka Server注册中心端的配置是对注册中心的特性配置。Eureka Server的配置全部在org.springframework.cloud.netflix.eureka.server.EurekaServerConfigBean里，实际上它是com.netflix.eureka.EurekaServerConfig的实现类，替代了netflix的默认实现。</p><p>Eureka Server的配置全部以eureka.server.xxx的格式进行配置。</p><p><strong>配置列表</strong></p><ul><li>enableSelfPreservation=true</li></ul><p>是否开启自我保护</p><ul><li>renewalPercentThreshold = 0.85</li></ul><p>自我保护续约百分比阀值因子。如果实际续约数小于续约数阀值，则开启自我保护</p><ul><li>renewalThresholdUpdateIntervalMs = 15 * 60 * 1000</li></ul><p>续约数阀值更新频率。</p><ul><li>peerEurekaNodesUpdateIntervalMs = 10 * 60 * 1000</li></ul><p>Eureka Server节点更新频率。</p><ul><li>enableReplicatedRequestCompression = false</li></ul><p>是否启用复制请求压缩。</p><ul><li>waitTimeInMsWhenSyncEmpty=5 * 60 * 1000</li></ul><p>当从其他节点同步实例信息为空时等待的时间。</p><ul><li>peerNodeConnectTimeoutMs=200</li></ul><p>节点间连接的超时时间。</p><ul><li>peerNodeReadTimeoutMs=200</li></ul><p>节点间读取信息的超时时间。</p><ul><li>peerNodeTotalConnections=1000</li></ul><p>节点间连接总数。</p><ul><li>peerNodeTotalConnectionsPerHost = 500;</li></ul><p>单个节点间连接总数。</p><ul><li>peerNodeConnectionIdleTimeoutSeconds = 30;</li></ul><p>节点间连接空闲超时时间。</p><ul><li>retentionTimeInMSInDeltaQueue = 3 * MINUTES;</li></ul><p>增量队列的缓存时间。</p><ul><li>deltaRetentionTimerIntervalInMs = 30 * 1000;</li></ul><p>清理增量队列中过期的频率。</p><ul><li>evictionIntervalTimerInMs = 60 * 1000;</li></ul><p>剔除任务频率。</p><ul><li>responseCacheAutoExpirationInSeconds = 180;</li></ul><p>注册列表缓存超时时间（当注册列表没有变化时）</p><ul><li>responseCacheUpdateIntervalMs = 30 * 1000;</li></ul><p>注册列表缓存更新频率。</p><ul><li>useReadOnlyResponseCache = true;</li></ul><p>是否开启注册列表的二级缓存。</p><ul><li>disableDelta=false。</li></ul><p>是否为client提供增量信息。</p><ul><li>maxThreadsForStatusReplication = 1;</li></ul><p>状态同步的最大线程数。</p><ul><li>maxElementsInStatusReplicationPool = 10000;</li></ul><p>状态同步队列的最大容量。</p><ul><li>syncWhenTimestampDiffers = true;</li></ul><p>当时间差异时是否同步。</p><ul><li>registrySyncRetries = 0;</li></ul><p>注册信息同步重试次数。</p><ul><li>registrySyncRetryWaitMs = 30 * 1000;</li></ul><p>注册信息同步重试期间的时间间隔。</p><ul><li>maxElementsInPeerReplicationPool = 10000;</li></ul><p>节点间同步事件的最大容量。</p><ul><li>minThreadsForPeerReplication = 5;</li></ul><p>节点间同步的最小线程数。</p><ul><li>maxThreadsForPeerReplication = 20;</li></ul><p>节点间同步的最大线程数。</p><ul><li>maxTimeForReplication = 30000;</li></ul><p>节点间同步的最大时间，单位为毫秒。</p><ul><li>disableDeltaForRemoteRegions = false；</li></ul><p>是否启用远程区域增量。</p><ul><li>remoteRegionConnectTimeoutMs = 1000;</li></ul><p>远程区域连接超时时间。</p><ul><li>remoteRegionReadTimeoutMs = 1000;</li></ul><p>远程区域读取超时时间。</p><ul><li>remoteRegionTotalConnections = 1000;</li></ul><p>远程区域最大连接数</p><ul><li>remoteRegionTotalConnectionsPerHost = 500;</li></ul><p>远程区域单机连接数</p><ul><li>remoteRegionConnectionIdleTimeoutSeconds = 30;</li></ul><p>远程区域连接空闲超时时间。</p><ul><li>remoteRegionRegistryFetchInterval = 30;</li></ul><p>远程区域注册信息拉取频率。</p><ul><li>remoteRegionFetchThreadPoolSize = 20;</li></ul><p>远程区域注册信息线程数。</p><h2 id="Eureka-DashBoard注册中心仪表盘配置"><a href="#Eureka-DashBoard注册中心仪表盘配置" class="headerlink" title="Eureka  DashBoard注册中心仪表盘配置"></a><strong>Eureka  DashBoard注册中心仪表盘配置</strong></h2><p>注册中心仪表盘的配置主要是控制注册中心的可视化展示。以eureka.dashboard.xxx的格式配置。</p><ul><li>path=”/“</li></ul><p>仪表盘访问路径</p><ul><li>enabled=true</li></ul><p>是否启用仪表盘</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud概述</title>
      <link href="/2020/08/10/spring-cloud-gai-shu/"/>
      <url>/2020/08/10/spring-cloud-gai-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-微服务架构"><a href="#1-微服务架构" class="headerlink" title="1.微服务架构"></a>1.微服务架构</h3><ul><li><p>微服务架构的演变</p><p><img src="/2020/08/10/spring-cloud-gai-shu/001.jpg"></p></li><li><p>微服务架构的描述</p><p>（1）微服务是系统架构上的一种设计风格,它的主旨是将一个原本独立的系统拆分成多个小型服务,这些小型服务都在各自独立的进程中运行,服务之间一般通过 HTTP 的 RESTfuL API 进行通信协作。</p><p>（2）被拆分成的每一个小型服务都围绕着系统中的某一项或些耦合度较高的业务功能进行构建,并且每个服务都维护着白身的数据存储、业务开发自动化测试案例以及独立部署机制。</p><p>（3）由于有了轻量级的通信协作基础,所以这些微服务可以使用不同的语言来编写。 </p></li></ul><p><img src="/2020/08/10/spring-cloud-gai-shu/002.jpg"></p><h3 id="2-Spring-Cloud"><a href="#2-Spring-Cloud" class="headerlink" title="2.Spring Cloud"></a>2.Spring Cloud</h3><ul><li><p>描述</p><p>Spring Cloud 是一系列框架的有序集合。</p><p>Spring Cloud 并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来。</p><p>通过 Spring Boot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><p>它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、 断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p><p>Spring Cloud项目官方网址：<a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a> </p></li></ul><p><img src="/2020/08/10/spring-cloud-gai-shu/003.jpg"></p><p>​         </p><p>​        Spring Cloud 版本命名方式采用了伦敦地铁站的名称，同时根据字母表的顺序来对应版本时间顺序，比如：最早的Release版本：Angel，第二个Release版本：Brixton，然后是Camden、    Dalston、Edgware，Finchley，Greenwich，Hoxton。</p><h3 id="3-Spring-Cloud与Dubbo对比"><a href="#3-Spring-Cloud与Dubbo对比" class="headerlink" title="3.Spring Cloud与Dubbo对比"></a>3.Spring Cloud与Dubbo对比</h3><ul><li>Spring Cloud 与 Dubbo 都是实现微服务有效的工具。</li><li>Dubbo 只是实现了服务治理，而 Spring Cloud 子项目分别覆盖了微服务架构下的众多部件。</li><li>Dubbo 使用 RPC 通讯协议，Spring Cloud 使用 RESTful 完成通信，Dubbo 效率略高于 Spring Cloud</li></ul><p><img src="/2020/08/10/spring-cloud-gai-shu/004.jpg"></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>​    微服务就是将项目的各个模块拆分为可独立运行、部署、测试的架构设计风格。</p><p>​    Spring 公司将其他公司中微服务架构常用的组件整合起来，并使用 SpringBoot 简化其开发、配置。称为 Spring Cloud</p><p>​    Spring Cloud 与 Dubbo都是实现微服务有效的工具。Dubbo 性能更好，而 Spring Cloud 功能更全面。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ基本程序编写</title>
      <link href="/2020/08/09/rabbitmq-ji-ben-cheng-xu-bian-xie/"/>
      <url>/2020/08/09/rabbitmq-ji-ben-cheng-xu-bian-xie/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-搭建示例工程"><a href="#3-1-搭建示例工程" class="headerlink" title="3.1. 搭建示例工程"></a>3.1. 搭建示例工程</h2><h3 id="3-1-1-创建工程"><a href="#3-1-1-创建工程" class="headerlink" title="3.1.1. 创建工程"></a>3.1.1. 创建工程</h3><p><img src="/2020/08/09/rabbitmq-ji-ben-cheng-xu-bian-xie/1558319510387.png"></p><p><img src="/2020/08/09/rabbitmq-ji-ben-cheng-xu-bian-xie/1558319546688.png"></p><h3 id="3-1-2-添加依赖"><a href="#3-1-2-添加依赖" class="headerlink" title="3.1.2. 添加依赖"></a>3.1.2. 添加依赖</h3><p>往aliyun-rabbitmq的pom.xml文件中添加如下依赖：</p><pre class=" language-xml"><code class="language-xml">        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.rabbitmq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>amqp-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.6.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h2 id="3-2-编写生产者"><a href="#3-2-编写生产者" class="headerlink" title="3.2. 编写生产者"></a>3.2. 编写生产者</h2><p>编写消息生产者ren.aliyun.rabbitmq.simple.Producer</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> ren<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>simple<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Channel<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Connection<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>ConnectionFactory<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> String QUEUE_NAME <span class="token operator">=</span> <span class="token string">"simple_queue"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建连接工厂</span>        ConnectionFactory connectionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//主机地址;默认为 localhost</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//连接端口;默认为 5672</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//虚拟主机名称;默认为 /</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/aliyun"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//连接用户名；默认为guest</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"aliyun"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//连接密码；默认为guest</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"aliyun"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建连接</span>        Connection connection <span class="token operator">=</span> connectionFactory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建频道</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 声明（创建）队列</span>        <span class="token comment" spellcheck="true">/**         * 参数1：队列名称         * 参数2：是否定义持久化队列         * 参数3：是否独占本次连接         * 参数4：是否在不使用的时候自动删除队列         * 参数5：队列其它参数         */</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 要发送的信息</span>        String message <span class="token operator">=</span> <span class="token string">"你好；小兔子！"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 参数1：交换机名称，如果没有指定则使用默认Default Exchage         * 参数2：路由key,简单模式可以传递队列名称         * 参数3：消息其它属性         * 参数4：消息内容         */</span>        channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> QUEUE_NAME<span class="token punctuation">,</span> null<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已发送消息："</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 关闭资源</span>        channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>在执行上述的消息发送之后；可以登录rabbitMQ的管理控制台，可以发现队列和其消息：</p><p><img src="/2020/08/09/rabbitmq-ji-ben-cheng-xu-bian-xie/1556006638979.png"></p><p><img src="/2020/08/09/rabbitmq-ji-ben-cheng-xu-bian-xie/1556006647177.png"></p><h2 id="3-3-编写消费者"><a href="#3-3-编写消费者" class="headerlink" title="3.3. 编写消费者"></a>3.3. 编写消费者</h2><p>抽取创建connection的工具类ren.aliyun.rabbitmq.util.ConnectionUtil；</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> ren<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>util<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Connection<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>ConnectionFactory<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConnectionUtil</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Connection <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建连接工厂</span>        ConnectionFactory connectionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//主机地址;默认为 localhost</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//连接端口;默认为 5672</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//虚拟主机名称;默认为 /</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/aliyun"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//连接用户名；默认为guest</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"aliyun"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//连接密码；默认为guest</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"aliyun"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建连接</span>        <span class="token keyword">return</span> connectionFactory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>编写消息的消费者ren.aliyun.rabbitmq.simple.Consumer</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> ren<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>simple<span class="token punctuation">;</span><span class="token keyword">import</span> ren<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ConnectionUtil<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建频道</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 声明（创建）队列</span>        <span class="token comment" spellcheck="true">/**         * 参数1：队列名称         * 参数2：是否定义持久化队列         * 参数3：是否独占本次连接         * 参数4：是否在不使用的时候自动删除队列         * 参数5：队列其它参数         */</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>Producer<span class="token punctuation">.</span>QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建消费者；并设置消息处理</span>        DefaultConsumer consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token comment" spellcheck="true">/**             * consumerTag 消息者标签，在channel.basicConsume时候可以指定             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)             * properties 属性信息             * body 消息             */</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//路由key</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"路由key为："</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getRoutingKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//交换机</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"交换机为："</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//消息id</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消息id为："</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//收到的消息</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到的消息为："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//监听消息</span>        <span class="token comment" spellcheck="true">/**         * 参数1：队列名称         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认         * 参数3：消息接收到后回调         */</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>Producer<span class="token punctuation">.</span>QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//不关闭资源，应该一直监听消息</span>        <span class="token comment" spellcheck="true">//channel.close();</span>        <span class="token comment" spellcheck="true">//connection.close();</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4. 小结"></a>3.4. 小结</h2><p>上述的入门案例中中其实使用的是如下的简单模式：</p><p><img src="/2020/08/09/rabbitmq-ji-ben-cheng-xu-bian-xie/1555991074575.png"></p><p>在上图的模型中，有以下概念：</p><ul><li>P：生产者，也就是要发送消息的程序</li><li>C：消费者：消息的接受者，会一直等待消息到来。</li><li>queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件概述</title>
      <link href="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/"/>
      <url>/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-什么是消息中间件"><a href="#1-1-什么是消息中间件" class="headerlink" title="1.1. 什么是消息中间件"></a>1.1. 什么是消息中间件</h2><p>MQ全称为Message Queue，消息队列是应用程序和应用程序之间的通信方法，是在消息的传输过程中保存消息的容器，多用于分布式系统之间进行通信。</p><ul><li><p>总结<br>MQ，消息队列，存储消息的中间件<br>分布式系统通信两种方式：直接远程调用 和 借助第三方 完成间接通信<br>发送方称为生产者，接收方称为消费者</p></li><li><p>为什么使用MQ</p><p>在项目中，可将一些无需即时返回且耗时的操作提取出来，进行<strong>异步处理</strong>，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而<strong>提高</strong>了<strong>系统</strong>的<strong>吞吐量</strong>。</p></li><li><p>MQ的优势(开发中消息队列通常有如下应用场景)：</p><p>1、任务<strong>异步</strong>处理</p><p>将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。</p><p><img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/yb1.jpg"></p><p><img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/yb2.jpg"></p><p>2、应用程序<strong>解耦合</strong></p><p>MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。</p></li></ul><p><img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/y1.jpg"><br><img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/y2.jpg"></p><p>  3、<strong>削峰填谷</strong></p><p>  如订单系统，在下单的时候就会往数据库写数据。但是数据库只能支撑每秒1000左右的并发写入，并发量再高就容易宕机。低峰期的时候并发也就100多个，但是在高峰期时候，并发量会突然激增到5000以上，这个时候数据库肯定卡死了。</p><p>  <img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/01.jpg"></p><p>  消息被MQ保存起来了，然后系统就可以按照自己的消费能力来消费，比如每秒1000个数据，这样慢慢写入数据库，这样就不会卡死数据库了。</p><p>  <img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/02.jpg"></p><p>  但是使用了MQ之后，限制消费消息的速度为1000，但是这样一来，高峰期产生的数据势必会被积压在MQ中，高峰就被“削”掉了。但是因为消息积压，在高峰期过后的一段时间内，消费消息的速度还是会维持在1000QPS，直到消费完积压的消息,这就叫做“填谷”</p><p>  <img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/03.jpg"></p><p><img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/xf1.jpg"></p><p><img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/xf2.jpg"></p><ul><li><p>MQ的劣势</p><p>系统可用性降低（系统引入的外部依赖越多，系统稳定性越差。一旦 MQ 宕机，就会对业务造成影响。如何保证MQ的高可用？）<br>系统复杂度提高（MQ 的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过 MQ 进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？）<br>一致性问题（A 系统处理完业务，通过 MQ 给B、C、D三个系统发消息数据，如果 B 系统、C 系统处理成功，D 系统处理失败。如何保证消息数据处理的一致性？）</p></li><li><p>既然 MQ 有优势也有劣势，那么使用 MQ 需要满足什么条件呢？</p><p>①生产者不需要从消费者处获得反馈。引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做，上层却当成动作做完了继续往后走，即所谓异步成为了可能。</p><p>②容许短暂的不一致性。</p><p>③确实是用了有效果。即解耦、提速、削峰这些方面的收益，超过加入MQ，管理MQ这些成本。</p></li></ul><h2 id="1-2-AMQP-和-JMS"><a href="#1-2-AMQP-和-JMS" class="headerlink" title="1.2. AMQP 和 JMS"></a>1.2. AMQP 和 JMS</h2><p>MQ是消息通信的模型；实现MQ的大致有两种主流方式：AMQP、JMS。</p><h3 id="1-2-1-AMQP"><a href="#1-2-1-AMQP" class="headerlink" title="1.2.1. AMQP"></a>1.2.1. AMQP</h3><p>AMQP（高级队列协议）是一种网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。2006年，AMQP 规范发布。类比HTTP。更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。</p><h3 id="1-2-2-JMS"><a href="#1-2-2-JMS" class="headerlink" title="1.2.2. JMS"></a>1.2.2. JMS</h3><p>JMS即Java消息服务（JavaMessage Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p><p>JMS 是 JavaEE 规范中的一种，类比JDBC</p><p>l很多消息中间件都实现了JMS规范，例如：ActiveMQ。RabbitMQ 官方没有提供 JMS 的实现包，但是开源社区有</p><h3 id="1-2-3-AMQP-与-JMS-区别"><a href="#1-2-3-AMQP-与-JMS-区别" class="headerlink" title="1.2.3. AMQP 与 JMS 区别"></a>1.2.3. AMQP 与 JMS 区别</h3><ul><li>JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式</li><li>JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。</li><li>JMS规定了两种消息模式；而AMQP的消息模式更加丰富</li></ul><h2 id="1-3-消息队列产品"><a href="#1-3-消息队列产品" class="headerlink" title="1.3. 消息队列产品"></a>1.3. 消息队列产品</h2><p>市场上常见的消息队列有如下：</p><ul><li>ActiveMQ：基于JMS</li><li>ZeroMQ：基于C语言开发</li><li>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好</li><li>RocketMQ：基于JMS，阿里巴巴产品</li><li>Kafka：类似MQ的产品；分布式消息系统，高吞吐量</li></ul><h2 id="1-4-RabbitMQ"><a href="#1-4-RabbitMQ" class="headerlink" title="1.4. RabbitMQ"></a>1.4. RabbitMQ</h2><p>RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。</p><p>RabbitMQ官方地址：<a href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a></p><p><img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/RabbitMQ.jpg"></p><p>RabbitMQ 中的相关概念：</p><p>​        lBroker：接收和分发消息的应用，RabbitMQ Server就是 Message Broker</p><p>​        Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中    的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，    每个用户在自己的 vhost 创建 exchange／queue 等</p><p>​        Connection：publisher／consumer 和 broker 之间的 TCP 连接</p><p>​        Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection的    开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通    常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker     识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建    立 TCP connection 的开销</p><p>RabbitMQ提供了6种模式：简单模式，work模式，Publish/Subscribe发布与订阅模式，Routing路由模式，Topics主题模式，RPC远程调用模式（远程调用，不太算MQ；暂不作介绍）；</p><p>官网对应模式介绍：<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></p><p><img src="/2020/08/08/xiao-xi-zhong-jian-jian-gai-shu/assets/1555988678324.jpg" alt="1555988678324"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ安装说明</title>
      <link href="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/"/>
      <url>/2020/08/07/rabbitmq-an-zhuang-shuo-ming/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装依赖环境"><a href="#1-安装依赖环境" class="headerlink" title="1. 安装依赖环境"></a>1. 安装依赖环境</h2><p>在线安装依赖环境：</p><pre class=" language-shell"><code class="language-shell">yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz</code></pre><h2 id="2-安装Erlang"><a href="#2-安装Erlang" class="headerlink" title="2. 安装Erlang"></a>2. 安装Erlang</h2><p>上传</p><p>erlang-18.3-1.el7.centos.x86_64.rpm<br>socat-1.7.3.2-5.el7.lux.x86_64.rpm<br>rabbitmq-server-3.6.5-1.noarch.rpm</p><pre class=" language-sh"><code class="language-sh"># 安装rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm</code></pre><p>如果出现如下错误</p><p><img src="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/assets/1565526174751.png"></p><p>说明gblic 版本太低。我们可以查看当前机器的gblic 版本</p><pre class=" language-shell"><code class="language-shell">strings /lib64/libc.so.6 | grep GLIBC</code></pre><p><img src="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/assets/1565526264426.png"></p><p>当前最高版本2.12，需要2.15.所以需要升级glibc</p><ul><li><p>使用yum更新安装依赖</p><pre class=" language-shell"><code class="language-shell">sudo yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make -y</code></pre></li><li><p>下载rpm包</p><pre class=" language-shell"><code class="language-shell">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-utils-2.17-55.el6.x86_64.rpm &wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-static-2.17-55.el6.x86_64.rpm &wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-2.17-55.el6.x86_64.rpm &wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-common-2.17-55.el6.x86_64.rpm &wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-devel-2.17-55.el6.x86_64.rpm &wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-headers-2.17-55.el6.x86_64.rpm &wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/nscd-2.17-55.el6.x86_64.rpm &</code></pre></li><li><p>安装rpm包</p><pre class=" language-shell"><code class="language-shell">sudo rpm -Uvh *-2.17-55.el6.x86_64.rpm --force --nodeps</code></pre></li><li><p>安装完毕后再查看glibc版本,发现glibc版本已经到2.17了</p><pre class=" language-shell"><code class="language-shell">strings /lib64/libc.so.6 | grep GLIBC</code></pre></li></ul><p><img src="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/assets/1565528746057.png"></p><h2 id="3-安装RabbitMQ"><a href="#3-安装RabbitMQ" class="headerlink" title="3. 安装RabbitMQ"></a>3. 安装RabbitMQ</h2><pre class=" language-sh"><code class="language-sh"># 安装rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm# 安装rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm</code></pre><h2 id="4-开启管理界面及配置"><a href="#4-开启管理界面及配置" class="headerlink" title="4. 开启管理界面及配置"></a>4. 开启管理界面及配置</h2><pre class=" language-sh"><code class="language-sh"># 开启管理界面rabbitmq-plugins enable rabbitmq_management# 修改默认配置信息vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app # 比如修改密码、配置等等，例如：loopback_users 中的 <<"guest">>,只保留guest</code></pre><h2 id="5-启动"><a href="#5-启动" class="headerlink" title="5. 启动"></a>5. 启动</h2><pre class=" language-sh"><code class="language-sh">service rabbitmq-server start # 启动服务service rabbitmq-server stop # 停止服务service rabbitmq-server restart # 重启服务</code></pre><ul><li>设置配置文件</li></ul><pre class=" language-shell"><code class="language-shell">cd /usr/share/doc/rabbitmq-server-3.6.5/cp rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</code></pre><h2 id="6-配置虚拟主机及用户"><a href="#6-配置虚拟主机及用户" class="headerlink" title="6. 配置虚拟主机及用户"></a>6. 配置虚拟主机及用户</h2><h3 id="6-1-用户角色"><a href="#6-1-用户角色" class="headerlink" title="6.1. 用户角色"></a>6.1. 用户角色</h3><p>RabbitMQ在安装好后，可以访问<code>http://ip地址:15672</code> ；其自带了guest/guest的用户名和密码；如果需要创建自定义用户；那么也可以登录管理界面后，如下操作：</p><p><img src="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/assets/1565098043833.png"> </p><p><img src="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/assets/1565098315375.png"></p><p><strong>角色说明</strong>：</p><p>1、 超级管理员(administrator)</p><p>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p><p>2、 监控者(monitoring)</p><p>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p><p>3、 策略制定者(policymaker)</p><p>可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</p><p>4、 普通管理者(management)</p><p>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</p><p>5、 其他</p><p>无法登陆管理控制台，通常就是普通的生产者和消费者。</p><h3 id="6-2-Virtual-Hosts配置"><a href="#6-2-Virtual-Hosts配置" class="headerlink" title="6.2. Virtual Hosts配置"></a>6.2. Virtual Hosts配置</h3><p>像mysql拥有数据库的概念并且可以指定用户对库和表等操作的权限。RabbitMQ也有类似的权限管理；在RabbitMQ中可以虚拟消息服务器Virtual Host，每个Virtual Hosts相当于一个相对独立的RabbitMQ服务器，每个VirtualHost之间是相互隔离的。exchange、queue、message不能互通。 相当于mysql的db。Virtual Name一般以/开头。</p><h4 id="6-2-1-创建Virtual-Hosts"><a href="#6-2-1-创建Virtual-Hosts" class="headerlink" title="6.2.1. 创建Virtual Hosts"></a>6.2.1. 创建Virtual Hosts</h4><p><img src="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/assets/1565098496482.png"></p><h4 id="6-2-2-设置Virtual-Hosts权限"><a href="#6-2-2-设置Virtual-Hosts权限" class="headerlink" title="6.2.2. 设置Virtual Hosts权限"></a>6.2.2. 设置Virtual Hosts权限</h4><p><img src="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/assets/1565098585317.png"></p><p><img src="/2020/08/07/rabbitmq-an-zhuang-shuo-ming/assets/1565098719054.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
